# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'PortalConfigurationBusinessProfileArgs',
    'PortalConfigurationFeaturesArgs',
    'PortalConfigurationFeaturesCustomerUpdateArgs',
    'PortalConfigurationFeaturesInvoiceHistoryArgs',
    'PortalConfigurationFeaturesPaymentMethodUpdateArgs',
    'PortalConfigurationFeaturesSubscriptionCancelArgs',
    'PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs',
    'PortalConfigurationFeaturesSubscriptionPauseArgs',
    'PortalConfigurationFeaturesSubscriptionUpdateArgs',
    'PortalConfigurationFeaturesSubscriptionUpdateProductArgs',
    'PortalConfigurationLoginPageArgs',
    'PriceCurrencyOptionArgs',
    'PriceCurrencyOptionCustomUnitAmountArgs',
    'PriceCurrencyOptionTierArgs',
    'PriceRecurringArgs',
    'PriceTierArgs',
    'PriceTransformQuantityArgs',
    'PromotionCodeRestrictionsArgs',
]

@pulumi.input_type
class PortalConfigurationBusinessProfileArgs:
    def __init__(__self__, *,
                 headline: Optional[pulumi.Input[str]] = None,
                 privacy_policy_url: Optional[pulumi.Input[str]] = None,
                 terms_of_service_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] headline: String. The messaging shown to customers in the portal.
        :param pulumi.Input[str] privacy_policy_url: String. A link to the business's publicly available privacy policy.
        :param pulumi.Input[str] terms_of_service_url: String. A link to the business's publicly available terms of service.
        """
        if headline is not None:
            pulumi.set(__self__, "headline", headline)
        if privacy_policy_url is not None:
            pulumi.set(__self__, "privacy_policy_url", privacy_policy_url)
        if terms_of_service_url is not None:
            pulumi.set(__self__, "terms_of_service_url", terms_of_service_url)

    @property
    @pulumi.getter
    def headline(self) -> Optional[pulumi.Input[str]]:
        """
        String. The messaging shown to customers in the portal.
        """
        return pulumi.get(self, "headline")

    @headline.setter
    def headline(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "headline", value)

    @property
    @pulumi.getter(name="privacyPolicyUrl")
    def privacy_policy_url(self) -> Optional[pulumi.Input[str]]:
        """
        String. A link to the business's publicly available privacy policy.
        """
        return pulumi.get(self, "privacy_policy_url")

    @privacy_policy_url.setter
    def privacy_policy_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "privacy_policy_url", value)

    @property
    @pulumi.getter(name="termsOfServiceUrl")
    def terms_of_service_url(self) -> Optional[pulumi.Input[str]]:
        """
        String. A link to the business's publicly available terms of service.
        """
        return pulumi.get(self, "terms_of_service_url")

    @terms_of_service_url.setter
    def terms_of_service_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "terms_of_service_url", value)


@pulumi.input_type
class PortalConfigurationFeaturesArgs:
    def __init__(__self__, *,
                 customer_update: Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']] = None,
                 invoice_history: Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']] = None,
                 payment_method_update: Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']] = None,
                 subscription_cancel: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']] = None,
                 subscription_pauses: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]]] = None,
                 subscription_updates: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]] = None):
        """
        :param pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs'] customer_update: List(Resource). Information about updating the customer details in the portal. See Customer Update.
        :param pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs'] invoice_history: List(Resource). Information about showing the billing history in the portal. See Invoice History.
        :param pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs'] payment_method_update: List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        :param pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs'] subscription_cancel: List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]] subscription_pauses: List(Resource). Information about pausing subscriptions in the portal. See Subscription Pause.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]] subscription_updates: List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        if customer_update is not None:
            pulumi.set(__self__, "customer_update", customer_update)
        if invoice_history is not None:
            pulumi.set(__self__, "invoice_history", invoice_history)
        if payment_method_update is not None:
            pulumi.set(__self__, "payment_method_update", payment_method_update)
        if subscription_cancel is not None:
            pulumi.set(__self__, "subscription_cancel", subscription_cancel)
        if subscription_pauses is not None:
            pulumi.set(__self__, "subscription_pauses", subscription_pauses)
        if subscription_updates is not None:
            pulumi.set(__self__, "subscription_updates", subscription_updates)

    @property
    @pulumi.getter(name="customerUpdate")
    def customer_update(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']]:
        """
        List(Resource). Information about updating the customer details in the portal. See Customer Update.
        """
        return pulumi.get(self, "customer_update")

    @customer_update.setter
    def customer_update(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesCustomerUpdateArgs']]):
        pulumi.set(self, "customer_update", value)

    @property
    @pulumi.getter(name="invoiceHistory")
    def invoice_history(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']]:
        """
        List(Resource). Information about showing the billing history in the portal. See Invoice History.
        """
        return pulumi.get(self, "invoice_history")

    @invoice_history.setter
    def invoice_history(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesInvoiceHistoryArgs']]):
        pulumi.set(self, "invoice_history", value)

    @property
    @pulumi.getter(name="paymentMethodUpdate")
    def payment_method_update(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']]:
        """
        List(Resource). Information about updating payment methods in the portal. See Payment Method Update.
        """
        return pulumi.get(self, "payment_method_update")

    @payment_method_update.setter
    def payment_method_update(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesPaymentMethodUpdateArgs']]):
        pulumi.set(self, "payment_method_update", value)

    @property
    @pulumi.getter(name="subscriptionCancel")
    def subscription_cancel(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']]:
        """
        List(Resource). Information about canceling subscriptions in the portal. See Subscription Cancel.
        """
        return pulumi.get(self, "subscription_cancel")

    @subscription_cancel.setter
    def subscription_cancel(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelArgs']]):
        pulumi.set(self, "subscription_cancel", value)

    @property
    @pulumi.getter(name="subscriptionPauses")
    def subscription_pauses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]]]:
        """
        List(Resource). Information about pausing subscriptions in the portal. See Subscription Pause.
        """
        return pulumi.get(self, "subscription_pauses")

    @subscription_pauses.setter
    def subscription_pauses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionPauseArgs']]]]):
        pulumi.set(self, "subscription_pauses", value)

    @property
    @pulumi.getter(name="subscriptionUpdates")
    def subscription_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]]:
        """
        List(Resource). Information about updating subscriptions in the portal. See Subscription Update.
        """
        return pulumi.get(self, "subscription_updates")

    @subscription_updates.setter
    def subscription_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateArgs']]]]):
        pulumi.set(self, "subscription_updates", value)


@pulumi.input_type
class PortalConfigurationFeaturesCustomerUpdateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 allowed_updates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_updates: List(String). The types of customer updates that are supported [`name`, `email`, `address`, `shipping`, `phone`, `tax_id`]. When empty, customers are not updatable.
        """
        pulumi.set(__self__, "enabled", enabled)
        if allowed_updates is not None:
            pulumi.set(__self__, "allowed_updates", allowed_updates)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="allowedUpdates")
    def allowed_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List(String). The types of customer updates that are supported [`name`, `email`, `address`, `shipping`, `phone`, `tax_id`]. When empty, customers are not updatable.
        """
        return pulumi.get(self, "allowed_updates")

    @allowed_updates.setter
    def allowed_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_updates", value)


@pulumi.input_type
class PortalConfigurationFeaturesInvoiceHistoryArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class PortalConfigurationFeaturesPaymentMethodUpdateArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionCancelArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 cancellation_reason: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 proration_behavior: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs'] cancellation_reason: List(Resource). Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer. Details of this field is in Cancellation Reason.
        :param pulumi.Input[str] mode: String. Whether to cancel subscriptions immediately or at the end of the billing period. Valid value is either `immediately` or `at_period_end`
        :param pulumi.Input[str] proration_behavior: String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        pulumi.set(__self__, "enabled", enabled)
        if cancellation_reason is not None:
            pulumi.set(__self__, "cancellation_reason", cancellation_reason)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="cancellationReason")
    def cancellation_reason(self) -> Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']]:
        """
        List(Resource). Whether the cancellation reasons will be collected in the portal and which options are exposed to the customer. Details of this field is in Cancellation Reason.
        """
        return pulumi.get(self, "cancellation_reason")

    @cancellation_reason.setter
    def cancellation_reason(self, value: Optional[pulumi.Input['PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs']]):
        pulumi.set(self, "cancellation_reason", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        String. Whether to cancel subscriptions immediately or at the end of the billing period. Valid value is either `immediately` or `at_period_end`
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        return pulumi.get(self, "proration_behavior")

    @proration_behavior.setter
    def proration_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proration_behavior", value)


@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionCancelCancellationReasonArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 options: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[bool] enabled: Bool. Whether the feature is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] options: List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Whether the feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List(String). Which cancellation reasons will be given as options to the customer. Supported values are `too_expensive`, `missing_features`, `switched_service`, `unused`, `customer_service`, `too_complex`, `low_quality`, and `other`.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "options", value)


@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionPauseArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionUpdateArgs:
    def __init__(__self__, *,
                 default_allowed_updates: pulumi.Input[Sequence[pulumi.Input[str]]],
                 enabled: pulumi.Input[bool],
                 products: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]],
                 proration_behavior: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_allowed_updates: List(String). The types of subscription updates that are supported. When empty, subscriptions are not updatable. Supported values are `price`, `quantity`, and `promotion_code`.
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        :param pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]] products: List(Resource). The list of products that support subscription updates. See details Products.
        :param pulumi.Input[str] proration_behavior: String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        pulumi.set(__self__, "default_allowed_updates", default_allowed_updates)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "products", products)
        if proration_behavior is not None:
            pulumi.set(__self__, "proration_behavior", proration_behavior)

    @property
    @pulumi.getter(name="defaultAllowedUpdates")
    def default_allowed_updates(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List(String). The types of subscription updates that are supported. When empty, subscriptions are not updatable. Supported values are `price`, `quantity`, and `promotion_code`.
        """
        return pulumi.get(self, "default_allowed_updates")

    @default_allowed_updates.setter
    def default_allowed_updates(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "default_allowed_updates", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def products(self) -> pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]]:
        """
        List(Resource). The list of products that support subscription updates. See details Products.
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: pulumi.Input[Sequence[pulumi.Input['PortalConfigurationFeaturesSubscriptionUpdateProductArgs']]]):
        pulumi.set(self, "products", value)

    @property
    @pulumi.getter(name="prorationBehavior")
    def proration_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        String. Whether to create prorations when canceling subscriptions. Possible values are `none` and `create_prorations`, which is only compatible with `mode=immediately`. No prorations are generated when canceling a subscription at the end of its natural billing period.
        """
        return pulumi.get(self, "proration_behavior")

    @proration_behavior.setter
    def proration_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proration_behavior", value)


@pulumi.input_type
class PortalConfigurationFeaturesSubscriptionUpdateProductArgs:
    def __init__(__self__, *,
                 prices: pulumi.Input[Sequence[pulumi.Input[str]]],
                 product: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prices: List(String). The list of price IDs for the product that a subscription can be updated to.
        :param pulumi.Input[str] product: String. The product id.
        """
        pulumi.set(__self__, "prices", prices)
        pulumi.set(__self__, "product", product)

    @property
    @pulumi.getter
    def prices(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List(String). The list of price IDs for the product that a subscription can be updated to.
        """
        return pulumi.get(self, "prices")

    @prices.setter
    def prices(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "prices", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        String. The product id.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)


@pulumi.input_type
class PortalConfigurationLoginPageArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool. Set to true to generate a shareable URL login_page.url that will take your customers to a hosted login page for the customer portal.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class PriceCurrencyOptionArgs:
    def __init__(__self__, *,
                 currency: pulumi.Input[str],
                 custom_unit_amount: Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']] = None,
                 tax_behavior: Optional[pulumi.Input[str]] = None,
                 tiers: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] currency: String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        :param pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs'] custom_unit_amount: List(Resource). When set, 
               provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
               See details in custom unit amount.
        :param pulumi.Input[str] tax_behavior: String. Only required if a default tax behavior was not provided in the Stripe Tax settings. 
               Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
               One of `inclusive`, `exclusive`, or `unspecified`.
               Once specified as either inclusive or exclusive, it cannot be changed.
        :param pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]] tiers: List(Resource). Each element represents a pricing tier. 
               This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
               the same fields as the root tiers block
        :param pulumi.Input[int] unit_amount: Int. A positive integer in cents (or 0 for a free price) representing how much to charge.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
               decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        pulumi.set(__self__, "currency", currency)
        if custom_unit_amount is not None:
            pulumi.set(__self__, "custom_unit_amount", custom_unit_amount)
        if tax_behavior is not None:
            pulumi.set(__self__, "tax_behavior", tax_behavior)
        if tiers is not None:
            pulumi.set(__self__, "tiers", tiers)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)

    @property
    @pulumi.getter
    def currency(self) -> pulumi.Input[str]:
        """
        String. Three-letter ISO currency code, in lowercase - [supported currencies](https://stripe.com/docs/currencies).
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: pulumi.Input[str]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter(name="customUnitAmount")
    def custom_unit_amount(self) -> Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']]:
        """
        List(Resource). When set, 
        provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.
        See details in custom unit amount.
        """
        return pulumi.get(self, "custom_unit_amount")

    @custom_unit_amount.setter
    def custom_unit_amount(self, value: Optional[pulumi.Input['PriceCurrencyOptionCustomUnitAmountArgs']]):
        pulumi.set(self, "custom_unit_amount", value)

    @property
    @pulumi.getter(name="taxBehavior")
    def tax_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        String. Only required if a default tax behavior was not provided in the Stripe Tax settings. 
        Specifies whether the price is considered inclusive of taxes or exclusive of taxes.
        One of `inclusive`, `exclusive`, or `unspecified`.
        Once specified as either inclusive or exclusive, it cannot be changed.
        """
        return pulumi.get(self, "tax_behavior")

    @tax_behavior.setter
    def tax_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tax_behavior", value)

    @property
    @pulumi.getter
    def tiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]]:
        """
        List(Resource). Each element represents a pricing tier. 
        This parameter requires `billing_scheme` to be set to `tiered`. This resource can be used more than once and follows
        the same fields as the root tiers block
        """
        return pulumi.get(self, "tiers")

    @tiers.setter
    def tiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PriceCurrencyOptionTierArgs']]]]):
        pulumi.set(self, "tiers", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. A positive integer in cents (or 0 for a free price) representing how much to charge.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as unit_amount, but accepts a decimal value in cents with at most 12
        decimal places. Only one of unit_amount and unit_amount_decimal can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unit_amount_decimal", value)


@pulumi.input_type
class PriceCurrencyOptionCustomUnitAmountArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 maximum: Optional[pulumi.Input[int]] = None,
                 minimum: Optional[pulumi.Input[int]] = None,
                 preset: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        :param pulumi.Input[int] maximum: Int. The maximum unit amount the customer can specify for this item.
        :param pulumi.Input[int] minimum: Int. The minimum unit amount the customer can specify for this item. 
               Must be at least the minimum charge amount.
        :param pulumi.Input[int] preset: Int. The starting unit amount which can be updated by the customer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Bool. Pass in `true` to enable `custom_unit_amount`, otherwise omit `custom_unit_amount`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The maximum unit amount the customer can specify for this item.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The minimum unit amount the customer can specify for this item. 
        Must be at least the minimum charge amount.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The starting unit amount which can be updated by the customer.
        """
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "preset", value)


@pulumi.input_type
class PriceCurrencyOptionTierArgs:
    def __init__(__self__, *,
                 flat_amount: Optional[pulumi.Input[int]] = None,
                 flat_amount_decimal: Optional[pulumi.Input[float]] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None,
                 up_to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param pulumi.Input[float] flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param pulumi.Input[int] unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param pulumi.Input[int] up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @flat_amount.setter
    def flat_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flat_amount", value)

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @flat_amount_decimal.setter
    def flat_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "flat_amount_decimal", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unit_amount_decimal", value)

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[pulumi.Input[int]]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")

    @up_to.setter
    def up_to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "up_to", value)


@pulumi.input_type
class PriceRecurringArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[str],
                 aggregate_usage: Optional[pulumi.Input[str]] = None,
                 interval_count: Optional[pulumi.Input[int]] = None,
                 usage_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] interval: String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        :param pulumi.Input[str] aggregate_usage: String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
               Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
               record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
               which uses the usage record with the maximum reported usage during a period.
        :param pulumi.Input[int] interval_count: Int. The number of intervals between subscription billings. For
               example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
               12 months, or 52 weeks).
        :param pulumi.Input[str] usage_type: String. Configures how the quantity per period should be determined. Can be either `metered`
               or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
               the total usage based on usage records. Defaults to `licensed`.
        """
        pulumi.set(__self__, "interval", interval)
        if aggregate_usage is not None:
            pulumi.set(__self__, "aggregate_usage", aggregate_usage)
        if interval_count is not None:
            pulumi.set(__self__, "interval_count", interval_count)
        if usage_type is not None:
            pulumi.set(__self__, "usage_type", usage_type)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        String. Specifies billing frequency. Either `day`, `week`, `month` or `year`.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="aggregateUsage")
    def aggregate_usage(self) -> Optional[pulumi.Input[str]]:
        """
        String. Specifies a usage of aggregation strategy for prices of `usage_type=metered`.
        Allowed values are `sum` for summing up all usage during a period, `last_during_period` for using the last usage
        record reported within a period, `last_ever` for using the last usage record ever (across period bounds) or `max`
        which uses the usage record with the maximum reported usage during a period.
        """
        return pulumi.get(self, "aggregate_usage")

    @aggregate_usage.setter
    def aggregate_usage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate_usage", value)

    @property
    @pulumi.getter(name="intervalCount")
    def interval_count(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The number of intervals between subscription billings. For
        example, `interval=month` and `interval_count=3` bills every 3 months. Maximum of one year interval allowed (1 year,
        12 months, or 52 weeks).
        """
        return pulumi.get(self, "interval_count")

    @interval_count.setter
    def interval_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_count", value)

    @property
    @pulumi.getter(name="usageType")
    def usage_type(self) -> Optional[pulumi.Input[str]]:
        """
        String. Configures how the quantity per period should be determined. Can be either `metered`
        or `licensed`. `licensed` automatically bills the quantity set when adding it to a subscription. `metered` aggregates
        the total usage based on usage records. Defaults to `licensed`.
        """
        return pulumi.get(self, "usage_type")

    @usage_type.setter
    def usage_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "usage_type", value)


@pulumi.input_type
class PriceTierArgs:
    def __init__(__self__, *,
                 flat_amount: Optional[pulumi.Input[int]] = None,
                 flat_amount_decimal: Optional[pulumi.Input[float]] = None,
                 unit_amount: Optional[pulumi.Input[int]] = None,
                 unit_amount_decimal: Optional[pulumi.Input[float]] = None,
                 up_to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] flat_amount: Int. The flat billing amount for an entire tier, regardless of the number of units in the
               tier.
        :param pulumi.Input[float] flat_amount_decimal: Float. Same as `flat_amount`, but accepts a decimal value representing an integer
               in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        :param pulumi.Input[int] unit_amount: Int. The per-unit billing amount for each individual unit for which this tier applies.
        :param pulumi.Input[float] unit_amount_decimal: Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
               decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        :param pulumi.Input[int] up_to: Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
               previous tier adding one. Use `-1` to define a fallback tier.
        """
        if flat_amount is not None:
            pulumi.set(__self__, "flat_amount", flat_amount)
        if flat_amount_decimal is not None:
            pulumi.set(__self__, "flat_amount_decimal", flat_amount_decimal)
        if unit_amount is not None:
            pulumi.set(__self__, "unit_amount", unit_amount)
        if unit_amount_decimal is not None:
            pulumi.set(__self__, "unit_amount_decimal", unit_amount_decimal)
        if up_to is not None:
            pulumi.set(__self__, "up_to", up_to)

    @property
    @pulumi.getter(name="flatAmount")
    def flat_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The flat billing amount for an entire tier, regardless of the number of units in the
        tier.
        """
        return pulumi.get(self, "flat_amount")

    @flat_amount.setter
    def flat_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flat_amount", value)

    @property
    @pulumi.getter(name="flatAmountDecimal")
    def flat_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as `flat_amount`, but accepts a decimal value representing an integer
        in the minor units of the currency. Only one of `flat_amount` and `flat_amount_decimal` can be set.
        """
        return pulumi.get(self, "flat_amount_decimal")

    @flat_amount_decimal.setter
    def flat_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "flat_amount_decimal", value)

    @property
    @pulumi.getter(name="unitAmount")
    def unit_amount(self) -> Optional[pulumi.Input[int]]:
        """
        Int. The per-unit billing amount for each individual unit for which this tier applies.
        """
        return pulumi.get(self, "unit_amount")

    @unit_amount.setter
    def unit_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_amount", value)

    @property
    @pulumi.getter(name="unitAmountDecimal")
    def unit_amount_decimal(self) -> Optional[pulumi.Input[float]]:
        """
        Float. Same as `unit_amount`, but accepts a decimal value in cents with at most 12
        decimal places. Only one of `unit_amount` and `unit_amount_decimal` can be set.
        """
        return pulumi.get(self, "unit_amount_decimal")

    @unit_amount_decimal.setter
    def unit_amount_decimal(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unit_amount_decimal", value)

    @property
    @pulumi.getter(name="upTo")
    def up_to(self) -> Optional[pulumi.Input[int]]:
        """
        Int. Specifies the upper bound of this tier. The lower bound of a tier is the upper bound of the
        previous tier adding one. Use `-1` to define a fallback tier.
        """
        return pulumi.get(self, "up_to")

    @up_to.setter
    def up_to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "up_to", value)


@pulumi.input_type
class PriceTransformQuantityArgs:
    def __init__(__self__, *,
                 divide_by: pulumi.Input[int],
                 round: pulumi.Input[str]):
        """
        :param pulumi.Input[int] divide_by: Int. Divide usage by this number.
        :param pulumi.Input[str] round: String. After division, either round the result `up` or `down`.
        """
        pulumi.set(__self__, "divide_by", divide_by)
        pulumi.set(__self__, "round", round)

    @property
    @pulumi.getter(name="divideBy")
    def divide_by(self) -> pulumi.Input[int]:
        """
        Int. Divide usage by this number.
        """
        return pulumi.get(self, "divide_by")

    @divide_by.setter
    def divide_by(self, value: pulumi.Input[int]):
        pulumi.set(self, "divide_by", value)

    @property
    @pulumi.getter
    def round(self) -> pulumi.Input[str]:
        """
        String. After division, either round the result `up` or `down`.
        """
        return pulumi.get(self, "round")

    @round.setter
    def round(self, value: pulumi.Input[str]):
        pulumi.set(self, "round", value)


@pulumi.input_type
class PromotionCodeRestrictionsArgs:
    def __init__(__self__, *,
                 first_time_transaction: pulumi.Input[bool],
                 minimum_amount: pulumi.Input[int],
                 minimum_amount_currency: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] first_time_transaction: Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        :param pulumi.Input[int] minimum_amount: Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        :param pulumi.Input[str] minimum_amount_currency: String. Three-letter ISO code for `minimum_amount`.
        """
        pulumi.set(__self__, "first_time_transaction", first_time_transaction)
        pulumi.set(__self__, "minimum_amount", minimum_amount)
        pulumi.set(__self__, "minimum_amount_currency", minimum_amount_currency)

    @property
    @pulumi.getter(name="firstTimeTransaction")
    def first_time_transaction(self) -> pulumi.Input[bool]:
        """
        Bool. A Boolean indicating if the Promotion Code should only be redeemed for Customers without any successful payments or invoices.
        """
        return pulumi.get(self, "first_time_transaction")

    @first_time_transaction.setter
    def first_time_transaction(self, value: pulumi.Input[bool]):
        pulumi.set(self, "first_time_transaction", value)

    @property
    @pulumi.getter(name="minimumAmount")
    def minimum_amount(self) -> pulumi.Input[int]:
        """
        Int. Minimum amount required to redeem this Promotion Code into a Coupon (e.g., a purchase must be $100 or more to work).
        """
        return pulumi.get(self, "minimum_amount")

    @minimum_amount.setter
    def minimum_amount(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum_amount", value)

    @property
    @pulumi.getter(name="minimumAmountCurrency")
    def minimum_amount_currency(self) -> pulumi.Input[str]:
        """
        String. Three-letter ISO code for `minimum_amount`.
        """
        return pulumi.get(self, "minimum_amount_currency")

    @minimum_amount_currency.setter
    def minimum_amount_currency(self, value: pulumi.Input[str]):
        pulumi.set(self, "minimum_amount_currency", value)


