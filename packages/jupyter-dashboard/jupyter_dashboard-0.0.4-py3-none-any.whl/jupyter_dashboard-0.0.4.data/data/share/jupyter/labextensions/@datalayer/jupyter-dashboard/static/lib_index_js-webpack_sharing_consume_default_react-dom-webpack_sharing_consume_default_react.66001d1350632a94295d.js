"use strict";
(self["webpackChunk_datalayer_jupyter_dashboard"] = self["webpackChunk_datalayer_jupyter_dashboard"] || []).push([["lib_index_js-webpack_sharing_consume_default_react-dom-webpack_sharing_consume_default_react"],{

/***/ "../../../../icons/react/data1/esm/DashboardGreyIconLabIcon.js":
/*!*********************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardGreyIconLabIcon.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _DashboardGreyIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DashboardGreyIcon.svg */ "../../../../icons/react/data1/esm/DashboardGreyIcon.svg");


const dashboardGreyIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:dashboard-grey',
    svgstr: _DashboardGreyIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dashboardGreyIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardOutlineWhiteIconLabIcon.js":
/*!*****************************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardOutlineWhiteIconLabIcon.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _DashboardOutlineWhiteIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DashboardOutlineWhiteIcon.svg */ "../../../../icons/react/data1/esm/DashboardOutlineWhiteIcon.svg");


const dashboardOutlineWhiteIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:dashboard-outline-white',
    svgstr: _DashboardOutlineWhiteIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dashboardOutlineWhiteIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardTealIconLabIcon.js":
/*!*********************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardTealIconLabIcon.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _DashboardTealIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DashboardTealIcon.svg */ "../../../../icons/react/data1/esm/DashboardTealIcon.svg");


const dashboardTealIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:dashboard-teal',
    svgstr: _DashboardTealIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dashboardTealIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardWhiteIconLabIcon.js":
/*!**********************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardWhiteIconLabIcon.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _DashboardWhiteIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DashboardWhiteIcon.svg */ "../../../../icons/react/data1/esm/DashboardWhiteIcon.svg");


const dashboardWhiteIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:dashboard-white',
    svgstr: _DashboardWhiteIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dashboardWhiteIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/DragIndicatorIconLabIcon.js":
/*!*********************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DragIndicatorIconLabIcon.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _DragIndicatorIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragIndicatorIcon.svg */ "../../../../icons/react/data1/esm/DragIndicatorIcon.svg");


const dragIndicatorIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:drag-indicator',
    svgstr: _DragIndicatorIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dragIndicatorIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/DragIndicatorLinesIconLabIcon.js":
/*!**************************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DragIndicatorLinesIconLabIcon.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _DragIndicatorLinesIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DragIndicatorLinesIcon.svg */ "../../../../icons/react/data1/esm/DragIndicatorLinesIcon.svg");


const dragIndicatorLinesIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:drag-indicator-lines',
    svgstr: _DragIndicatorLinesIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dragIndicatorLinesIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/EditIconLabIcon.js":
/*!************************************************************!*\
  !*** ../../../../icons/react/data1/esm/EditIconLabIcon.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _EditIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditIcon.svg */ "../../../../icons/react/data1/esm/EditIcon.svg");


const editIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:edit',
    svgstr: _EditIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (editIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/FullscreenIconLabIcon.js":
/*!******************************************************************!*\
  !*** ../../../../icons/react/data1/esm/FullscreenIconLabIcon.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _FullscreenIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FullscreenIcon.svg */ "../../../../icons/react/data1/esm/FullscreenIcon.svg");


const fullscreenIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:fullscreen',
    svgstr: _FullscreenIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fullscreenIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/RedoIconLabIcon.js":
/*!************************************************************!*\
  !*** ../../../../icons/react/data1/esm/RedoIconLabIcon.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _RedoIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RedoIcon.svg */ "../../../../icons/react/data1/esm/RedoIcon.svg");


const redoIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:redo',
    svgstr: _RedoIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redoIconLabIcon);

/***/ }),

/***/ "../../../../icons/react/data1/esm/ViewIconLabIcon.js":
/*!************************************************************!*\
  !*** ../../../../icons/react/data1/esm/ViewIconLabIcon.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/ui-components/lib/icon/labicon */ "../../../../../node_modules/@jupyterlab/ui-components/lib/icon/labicon.js");
/* harmony import */ var _ViewIcon_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ViewIcon.svg */ "../../../../icons/react/data1/esm/ViewIcon.svg");


const viewIconLabIcon = new _jupyterlab_ui_components_lib_icon_labicon__WEBPACK_IMPORTED_MODULE_0__.LabIcon({
    name: '@datalayer/icons:view',
    svgstr: _ViewIcon_svg__WEBPACK_IMPORTED_MODULE_1__,
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (viewIconLabIcon);

/***/ }),

/***/ "./lib/dashboard/commands.js":
/*!***********************************!*\
  !*** ./lib/dashboard/commands.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CommandIDs": () => (/* binding */ CommandIDs)
/* harmony export */ });
/**
 * A namespace for dashboard command ids.
 */
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.deleteOutput = 'dashboard:delete-dashboard-widget';
    CommandIDs.undo = 'dashboard:undo';
    CommandIDs.redo = 'dashboard:redo';
    CommandIDs.save = 'dashboard:save';
    CommandIDs.saveAs = 'dashboard:save-as';
    CommandIDs.load = 'dashboard:load';
    CommandIDs.toggleFitContent = 'dashboard-widget:toggleFitContent';
    CommandIDs.toggleMode = 'dashboard:toggleMode';
    CommandIDs.setDimensions = 'dashboard:setDimensions';
    CommandIDs.cut = 'dashboard:cut';
    CommandIDs.copy = 'dashboard:copy';
    CommandIDs.paste = 'dashboard:paste';
    CommandIDs.runOutput = 'dashboard:run-output';
    CommandIDs.runAllAboveOutput = 'dashboard:run-all-above-output';
    CommandIDs.startFullscreen = 'dashboard:start-fullscreen';
    CommandIDs.createNew = 'dashboard:create-new';
    CommandIDs.setTileSize = 'dashboard:set-tile-size';
    CommandIDs.saveToMetadata = 'dashboard:save-to-metadata';
    CommandIDs.openFromMetadata = 'dashboard:open-from-metadata';
    CommandIDs.toggleWidgetMode = 'dashboard:toggle-widget-mode';
    CommandIDs.toggleInfiniteScroll = 'dashboard:toggle-infinite-scroll';
    CommandIDs.trimDashboard = 'dashboard:trim-dashboard';
})(CommandIDs || (CommandIDs = {}));


/***/ }),

/***/ "./lib/dashboard/content.js":
/*!**********************************!*\
  !*** ./lib/dashboard/content.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DASHBOARD_VERSION": () => (/* binding */ DASHBOARD_VERSION)
/* harmony export */ });
const DASHBOARD_VERSION = 1;


/***/ }),

/***/ "./lib/dashboard/dashboard.js":
/*!************************************!*\
  !*** ./lib/dashboard/dashboard.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DASHBOARD_CLASS": () => (/* binding */ DASHBOARD_CLASS),
/* harmony export */   "DROP_TARGET_CLASS": () => (/* binding */ DROP_TARGET_CLASS),
/* harmony export */   "Dashboard": () => (/* binding */ Dashboard),
/* harmony export */   "DashboardDocument": () => (/* binding */ DashboardDocument),
/* harmony export */   "DashboardDocumentFactory": () => (/* binding */ DashboardDocumentFactory),
/* harmony export */   "DashboardTracker": () => (/* binding */ DashboardTracker),
/* harmony export */   "IDashboardTracker": () => (/* binding */ IDashboardTracker),
/* harmony export */   "TOOLBAR_CLASS": () => (/* binding */ TOOLBAR_CLASS),
/* harmony export */   "TOOLBAR_MODE_SWITCHER_CLASS": () => (/* binding */ TOOLBAR_MODE_SWITCHER_CLASS),
/* harmony export */   "TOOLBAR_SELECT_CLASS": () => (/* binding */ TOOLBAR_SELECT_CLASS),
/* harmony export */   "openfullscreen": () => (/* binding */ openfullscreen)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "../../../../../node_modules/react/jsx-runtime.js");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/docregistry */ "webpack/sharing/consume/default/@jupyterlab/docregistry");
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/cells */ "webpack/sharing/consume/default/@jupyterlab/cells");
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./layout */ "./lib/dashboard/layout.js");
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./widget */ "./lib/dashboard/widget.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils */ "./lib/dashboard/utils.js");
/* harmony import */ var _commands__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./commands */ "./lib/dashboard/commands.js");













// HTML element classes
const DASHBOARD_CLASS = 'dsh-JupyterDashboard';
const DROP_TARGET_CLASS = 'dsh-DropTarget';
const TOOLBAR_MODE_SWITCHER_CLASS = 'dsh-ToolbarModeSwitcher';
const TOOLBAR_SELECT_CLASS = 'dsh-ToolbarSelector';
const TOOLBAR_CLASS = 'dsh-DashboardToolbar';
const IDashboardTracker = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.Token('jupyterlab_interactive_dashboard_editor');
class DashboardTracker extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6__.WidgetTracker {
}
/**
 * Main content widget for the Dashboard widget.
 */
class Dashboard extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_2__.Widget {
    constructor(options) {
        super(options);
        this.id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.UUID.uuid4();
        const { outputTracker, model } = options;
        this._model = model;
        this._context = options.context;
        const { widgetStore, mode } = model;
        this.layout = new _layout__WEBPACK_IMPORTED_MODULE_8__.DashboardLayout({
            widgetStore,
            outputTracker,
            model,
            mode,
            width: options.dashboardWidth || Dashboard.DEFAULT_WIDTH,
            height: options.dashboardHeight || Dashboard.DEFAULT_HEIGHT
        });
        widgetStore.connectDashboard(this);
        this._model.loaded.connect(this.updateLayoutFromWidgetStore, this);
        this.addClass(DASHBOARD_CLASS);
    }
    /**
     * Create click listeners on attach
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.node.addEventListener('lm-dragenter', this, true);
        this.node.addEventListener('lm-dragleave', this, true);
        this.node.addEventListener('lm-dragover', this, true);
        this.node.addEventListener('lm-drop', this, true);
        this.node.addEventListener('lm-dragend', this, true);
        this.node.addEventListener('scroll', this);
    }
    /**
     * Remove click listeners on detach
     */
    onBeforeDetach(msg) {
        super.onBeforeDetach(msg);
        this.node.removeEventListener('lm-dragenter', this, true);
        this.node.removeEventListener('lm-dragleave', this, true);
        this.node.removeEventListener('lm-dragover', this, true);
        this.node.removeEventListener('lm-drop', this, true);
        this.node.removeEventListener('scroll', this);
    }
    /**
     * Handle the `'lm-dragenter'` event for the widget.
     */
    _evtDragEnter(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Handle the `'lm-dragleave'` event for the widget.
     */
    _evtDragLeave(event) {
        this.removeClass(DROP_TARGET_CLASS);
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Handle the `'lm-dragover'` event for the widget.
     */
    _evtDragOver(event) {
        this.addClass(DROP_TARGET_CLASS);
        event.dropAction = 'copy';
        const source = event.source;
        const pos = source?.pos;
        if (pos && source.mode === 'grid-edit') {
            pos.left = event.offsetX + this.node.scrollLeft;
            pos.top = event.offsetY + this.node.scrollTop;
            this.layout.drawDropZone(pos, '#2b98f0');
        }
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Handle the `'lm-drop'` event for the widget.
     */
    _evtDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        const left = event.offsetX + this.node.scrollLeft;
        const top = event.offsetY + this.node.scrollTop;
        if (event.proposedAction === 'move') {
            const widget = event.source;
            const oldDashboard = widget.parent;
            const width = widget.node.offsetWidth;
            const height = widget.node.offsetHeight;
            const pos = { left, top, width, height };
            if (oldDashboard === this) {
                // dragging in same dashboard.ono
                this.updateWidget(widget, pos);
            }
            else {
                // dragging between dashboards
                const info = {
                    widgetId: _widget__WEBPACK_IMPORTED_MODULE_9__.DashboardWidget.createDashboardWidgetId(),
                    notebookId: widget.notebookId,
                    cellId: widget.cellId,
                    pos,
                    removed: false
                };
                const newWidget = this.createWidget(info);
                this.addWidget(newWidget, pos);
                oldDashboard.deleteWidget(widget);
            }
            // dragging from notebook -> dashboard.
        }
        else if (event.proposedAction === 'copy') {
            const notebook = event.source.parent;
            let cell;
            if (event.source.activeCell instanceof _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_4__.MarkdownCell) {
                cell = notebook.content.activeCell;
            }
            else {
                cell = notebook.content.activeCell;
            }
            const info = {
                widgetId: _widget__WEBPACK_IMPORTED_MODULE_9__.DashboardWidget.createDashboardWidgetId(),
                notebookId: (0,_utils__WEBPACK_IMPORTED_MODULE_10__.addNotebookId)(notebook),
                cellId: (0,_utils__WEBPACK_IMPORTED_MODULE_10__.addCellId)(cell),
                pos: {
                    left,
                    top,
                    width: _widget__WEBPACK_IMPORTED_MODULE_9__.DashboardWidget.DEFAULT_WIDTH,
                    height: _widget__WEBPACK_IMPORTED_MODULE_9__.DashboardWidget.DEFAULT_HEIGHT
                },
                removed: false
            };
            const newWidget = this.createWidget(info, true);
            this.addWidget(newWidget, info.pos);
        }
        else {
            return;
        }
        this.removeClass(DROP_TARGET_CLASS);
    }
    handleEvent(event) {
        switch (event.type) {
            case 'scroll':
                this._evtScroll(event);
                break;
            case 'lm-dragenter':
                this._evtDragEnter(event);
                break;
            case 'lm-dragleave':
                this._evtDragLeave(event);
                break;
            case 'lm-dragover':
                this._evtDragOver(event);
                break;
            case 'lm-drop':
                this._evtDrop(event);
                break;
        }
    }
    _evtScroll(_event) {
        const model = this.model;
        if (model.scrollMode !== 'infinite') {
            return;
        }
        const elem = this.node;
        const rightEdge = elem.offsetWidth + elem.scrollLeft;
        const bottomEdge = elem.offsetHeight + elem.scrollTop;
        if (rightEdge >= model.width && rightEdge > this._oldRightEdge) {
            model.width += 200;
        }
        if (bottomEdge >= model.height && bottomEdge > this._oldBottomEdge) {
            model.height += 200;
        }
        this._oldBottomEdge = bottomEdge;
        this._oldRightEdge = rightEdge;
    }
    /**
     * Add a widget to the layout.
     *
     * @param widget - the widget to add.
     */
    addWidget(widget, pos) {
        this.layout.addWidget(widget, pos);
    }
    updateWidget(widget, pos) {
        return this.layout.updateWidget(widget, pos);
    }
    /**
     * Remove a widget from the layout.
     *
     * @param widget - the widget to remove.
     *
     * ### Notes
     * This is basically the same as deleteWidget but fulfills the type
     * signature requirements of the extended class.
     */
    removeWidget(widget) {
        this.layout.removeWidget(widget);
    }
    /**
     * Remove a widget from the layout.
     *
     * @param widget - the widget to remove.
     *
     */
    deleteWidget(widget) {
        return this.layout.deleteWidget(widget);
    }
    /**
     * Adds a dashboard widget's information to the widgetStore.
     *
     * @param info - the information to add to the widgetStore.
     */
    updateWidgetInfo(info) {
        this.layout.updateWidgetInfo(info);
    }
    /**
     * Mark a widget as deleted in the widgetStore.
     *
     * @param widget - the widget to mark as deleted.
     */
    deleteWidgetInfo(widget) {
        this.layout.deleteWidgetInfo(widget);
    }
    /**
     * Update a widgetStore entry for a widget given that widget.
     *
     * @param widget - the widget to update from.
     */
    updateInfoFromWidget(widget) {
        this.layout.updateInfoFromWidget(widget);
    }
    /**
     * Updates the layout based on the state of the datastore.
     */
    updateLayoutFromWidgetStore() {
        this.layout.updateLayoutFromWidgetStore();
    }
    /**
     * Undo the last change to the layout.
     */
    undo() {
        this.layout.undo();
    }
    /**
     * Redo the last change to the layout.
     */
    redo() {
        this.layout.redo();
    }
    createWidget(info, fit) {
        return this.layout.createWidget(info, fit);
    }
    saveToNotebookMetadata() {
        // Get a list of all notebookIds used in the dashboard.
        const widgets = Array.from(this.model.widgetStore.getWidgets());
        const notebookIds = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.toArray)((0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.map)(widgets, record => record.notebookId));
        if (!notebookIds.every(v => v === notebookIds[0])) {
            throw new Error('Only single notebook dashboards can be saved to metadata.');
        }
        const notebookId = notebookIds[0];
        const notebookTracker = this.model.notebookTracker;
        const notebook = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.getNotebookById)(notebookId, notebookTracker);
        (0,_utils__WEBPACK_IMPORTED_MODULE_10__.updateMetadata)(notebook, { hasDashboard: true });
        const cells = notebook.content.widgets;
        const widgetMap = new Map(widgets.map(widget => [widget.cellId, widget.pos]));
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_5__.each)(cells, cell => {
            const cellId = (0,_utils__WEBPACK_IMPORTED_MODULE_10__.getCellId)(cell);
            const pos = widgetMap.get(cellId);
            if (pos != null) {
                (0,_utils__WEBPACK_IMPORTED_MODULE_10__.updateMetadata)(cell, { pos, hidden: false });
            }
            else {
                (0,_utils__WEBPACK_IMPORTED_MODULE_10__.updateMetadata)(cell, { hidden: true });
            }
        });
        notebook?.context.save();
    }
    get model() {
        return this._model;
    }
    get context() {
        return this._context;
    }
    _model;
    _context;
    _oldRightEdge = 0;
    _oldBottomEdge = 0;
}
/**
 * Namespace for DashboardArea options.
 */
(function (Dashboard) {
    Dashboard.DEFAULT_WIDTH = 1920;
    Dashboard.DEFAULT_HEIGHT = 1080;
})(Dashboard || (Dashboard = {}));
class DashboardDocument extends _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__.DocumentWidget {
    constructor(options) {
        let { content, reveal } = options;
        const { context, commandRegistry } = options;
        const model = context.model;
        model.path = context.path;
        content = content || new Dashboard({ ...options, model, context });
        reveal = Promise.all([reveal, context.ready]);
        super({
            ...options,
            content: content,
            reveal
        });
        // Build the toolbar
        this.toolbar.addClass(TOOLBAR_CLASS);
        const commands = commandRegistry;
        const { save, undo, redo, cut, copy, paste } = _commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs;
        const args = { toolbar: true, dashboardId: content.id };
        const makeToolbarButton = (id, tooltip) => {
            const button = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6__.CommandToolbarButton({ args, commands, id });
            button.node.title = tooltip;
            return button;
        };
        const saveButton = makeToolbarButton(save, 'Save');
        const undoButton = makeToolbarButton(undo, 'Undo');
        const redoButton = makeToolbarButton(redo, 'Redo');
        const cutButton = makeToolbarButton(cut, 'Cut the selected outputs');
        const copyButton = makeToolbarButton(copy, 'Copy the selected outputs');
        const pasteButton = makeToolbarButton(paste, 'Paste outputs from the clipboard');
        this.toolbar.addItem(save, saveButton);
        this.toolbar.addItem(undo, undoButton);
        this.toolbar.addItem(redo, redoButton);
        this.toolbar.addItem(cut, cutButton);
        this.toolbar.addItem(copy, copyButton);
        this.toolbar.addItem(paste, pasteButton);
        this.toolbar.addItem('spacer', _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6__.Toolbar.createSpacerItem());
        this.toolbar.addItem('switchMode', new DashboardDocument.DashboardModeSwitcher(content));
    }
}
(function (DashboardDocument) {
    class DashboardModeSwitcher extends _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_6__.ReactWidget {
        constructor(dashboard) {
            super();
            this.addClass(TOOLBAR_MODE_SWITCHER_CLASS);
            this._dashboard = dashboard;
            if (dashboard.model) {
                this.update();
            }
            dashboard.model.stateChanged.connect((_sender, change) => {
                if (change.name === 'mode') {
                    this.update();
                }
            }, this);
        }
        _handleChange(that) {
            return (event) => {
                that.dashboard.model.mode = event.target.value;
            };
        }
        render() {
            const value = this._dashboard.model.mode;
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.HTMLSelect, { className: TOOLBAR_SELECT_CLASS, onChange: this._handleChange(this), value: value, "aria-label": 'Mode', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: "present", children: "Present" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: "grid-edit", children: "Edit" })] }));
        }
        get dashboard() {
            return this._dashboard;
        }
        _dashboard;
    }
    DashboardDocument.DashboardModeSwitcher = DashboardModeSwitcher;
})(DashboardDocument || (DashboardDocument = {}));
class DashboardDocumentFactory extends _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_3__.ABCWidgetFactory {
    constructor(options) {
        super(options);
        this._commandRegistry = options.commandRegistry;
        this._outputTracker = options.outputTracker;
    }
    createNewWidget(context) {
        return new DashboardDocument({
            context,
            commandRegistry: this._commandRegistry,
            outputTracker: this._outputTracker
        });
    }
    _commandRegistry;
    _outputTracker;
}
/**
 * CURRENTLY UNUSED
 *
 * Opens a visual HTMLElement in fullscreen.
 *
 * @param node- the element to open in fullscreen.
 */
function openfullscreen(node) {
    // Trigger fullscreen
    const docElmWithBrowsersFullScreenFunctions = node;
    if (docElmWithBrowsersFullScreenFunctions.requestFullscreen) {
        docElmWithBrowsersFullScreenFunctions.requestFullscreen();
    }
    else if (docElmWithBrowsersFullScreenFunctions.mozRequestFullScreen) {
        /* Firefox */
        docElmWithBrowsersFullScreenFunctions.mozRequestFullScreen();
    }
    else if (docElmWithBrowsersFullScreenFunctions.webkitRequestFullscreen) {
        /* Chrome, Safari and Opera */
        docElmWithBrowsersFullScreenFunctions.webkitRequestFullscreen();
    }
    else if (docElmWithBrowsersFullScreenFunctions.msRequestFullscreen) {
        /* IE/Edge */
        docElmWithBrowsersFullScreenFunctions.msRequestFullscreen();
    }
}


/***/ }),

/***/ "./lib/dashboard/drag.js":
/*!*******************************!*\
  !*** ./lib/dashboard/drag.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Drag": () => (/* binding */ Drag)
/* harmony export */ });
/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/disposable */ "webpack/sharing/consume/default/@lumino/disposable");
/* harmony import */ var _lumino_disposable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_disposable__WEBPACK_IMPORTED_MODULE_0__);

/**
 * An object which manages a drag-drop operation.
 *
 * A drag object dispatches four different events to drop targets:
 *
 * - `'p-dragenter'` - Dispatched when the mouse enters the target
 *   element. This event must be canceled in order to receive any
 *   of the other events.
 *
 * - `'p-dragover'` - Dispatched when the mouse moves over the drop
 *   target. It must cancel the event and set the `dropAction` to one
 *   of the supported actions in order to receive drop events.
 *
 * - `'p-dragleave'` - Dispatched when the mouse leaves the target
 *   element. This includes moving the mouse into child elements.
 *
 * - `'p-drop'`- Dispatched when the mouse is released over the target
 *   element when the target indicates an appropriate drop action. If
 *   the event is canceled, the indicated drop action is returned to
 *   the initiator through the resolved promise.
 *
 * A drag operation can be terminated at any time by pressing `Escape`
 * or by disposing the drag object.
 *
 * A drag object has the ability to automatically scroll a scrollable
 * element when the mouse is hovered near one of its edges. To enable
 * this, add the `data-p-dragscroll` attribute to any element which
 * the drag object should consider for scrolling.
 *
 * #### Notes
 * This class is designed to be used when dragging and dropping custom
 * data *within* a single application. It is *not* a replacement for
 * the native drag-drop API. Instead, it provides an API which allows
 * drag operations to be initiated programmatically and enables the
 * transfer of arbitrary non-string objects; features which are not
 * possible with the native drag-drop API.
 */
class Drag {
    /**
     * Construct a new drag object.
     *
     * @param options - The options for initializing the drag.
     */
    constructor(options) {
        this.mimeData = options.mimeData;
        this.dragImage = options.dragImage || null;
        this.proposedAction = options.proposedAction || 'copy';
        this.supportedActions = options.supportedActions || 'all';
        this.source = options.source || null;
        this._dragAdjustX = options.dragAdjustX || 0;
        this._dragAdjustY = options.dragAdjustY || 0;
    }
    /**
     * Dispose of the resources held by the drag object.
     *
     * #### Notes
     * This will cancel the drag operation if it is active.
     */
    dispose() {
        // Do nothing if the drag object is already disposed.
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        // If there is a current target, dispatch a drag leave event.
        if (this._currentTarget) {
            const event = Private.createMouseEvent('mouseup', -1, -1);
            Private.dispatchDragLeave(this, this._currentTarget, null, event);
        }
        // Finalize the drag object with `'none'`.
        this._finalize('none');
    }
    /**
     * The mime data for the drag object.
     */
    mimeData;
    /**
     * The drag image element for the drag object.
     */
    dragImage;
    /**
     * The proposed drop action for the drag object.
     */
    proposedAction;
    /**
     * The supported drop actions for the drag object.
     */
    supportedActions;
    /**
     * Get the drag source for the drag object.
     */
    source;
    /**
     * Test whether the drag object is disposed.
     */
    get isDisposed() {
        return this._disposed;
    }
    /**
     * Start the drag operation at the specified client position.
     *
     * @param clientX - The client X position for the drag start.
     *
     * @param clientY - The client Y position for the drag start.
     *
     * @returns A promise which resolves to the result of the drag.
     *
     * #### Notes
     * If the drag has already been started, the promise created by the
     * first call to `start` is returned.
     *
     * If the drag operation has ended, or if the drag object has been
     * disposed, the returned promise will resolve to `'none'`.
     *
     * The drag object will be automatically disposed when drag operation
     * completes. This means `Drag` objects are for single-use only.
     *
     * This method assumes the left mouse button is already held down.
     */
    start(clientX, clientY) {
        // If the drag object is already disposed, resolve to `None`.
        if (this._disposed) {
            return Promise.resolve('none');
        }
        // If the drag has already been started, return the promise.
        if (this._promise) {
            return this._promise;
        }
        this._dragOffsetX = this._dragAdjustX - clientX;
        this._dragOffsetY = this._dragAdjustY - clientY;
        // Install the document listeners for the drag object.
        this._addListeners();
        // Attach the drag image at the specified client position.
        this._attachDragImage(clientX, clientY);
        // Create the promise which will be resolved on completion.
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
        });
        // Trigger a fake move event to kick off the drag operation.
        const event = Private.createMouseEvent('mousemove', clientX, clientY);
        document.dispatchEvent(event);
        // Return the pending promise for the drag operation.
        return this._promise;
    }
    /**
     * Handle the DOM events for the drag operation.
     *
     * @param event - The DOM event sent to the drag object.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the document. It should not be
     * called directly by user code.
     */
    handleEvent(event) {
        switch (event.type) {
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            default:
                // Stop all other events during drag-drop.
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    }
    /**
     * Handle the `'mousemove'` event for the drag object.
     */
    _evtMouseMove(event) {
        // Stop all input events during drag-drop.
        event.preventDefault();
        event.stopPropagation();
        // Update the current target node and dispatch enter/leave events.
        this._updateCurrentTarget(event);
        // Update the drag scroll element.
        this._updateDragScroll(event);
        // Move the drag image to the specified client position. This is
        // performed *after* dispatching to prevent unnecessary reflows.
        this.moveDragImage(event.clientX, event.clientY);
    }
    /**
     * Handle the `'mouseup'` event for the drag object.
     */
    _evtMouseUp(event) {
        // Stop all input events during drag-drop.
        event.preventDefault();
        event.stopPropagation();
        // Do nothing if the left button is not released.
        if (event.button !== 0) {
            return;
        }
        // Update the current target node and dispatch enter/leave events.
        // This prevents a subtle issue where the DOM mutates under the
        // cursor after the last move event but before the drop event.
        this._updateCurrentTarget(event);
        // If there is no current target, finalize with `'none'`.
        if (!this._currentTarget) {
            this._finalize('none');
            return;
        }
        // If the last drop action was `'none'`, dispatch a leave event
        // to the current target and finalize the drag with `'none'`.
        if (this._dropAction === 'none') {
            Private.dispatchDragLeave(this, this._currentTarget, null, event);
            this._finalize('none');
            return;
        }
        // Dispatch the drop event at the current target and finalize
        // with the resulting drop action.
        const action = Private.dispatchDrop(this, this._currentTarget, event);
        this._finalize(action);
    }
    /**
     * Handle the `'keydown'` event for the drag object.
     */
    _evtKeyDown(event) {
        // Stop all input events during drag-drop.
        event.preventDefault();
        event.stopPropagation();
        // Cancel the drag if `Escape` is pressed.
        if (event.keyCode === 27) {
            this.dispose();
        }
    }
    /**
     * Add the document event listeners for the drag object.
     */
    _addListeners() {
        document.addEventListener('mousedown', this, true);
        document.addEventListener('mousemove', this, true);
        document.addEventListener('mouseup', this, true);
        document.addEventListener('mouseenter', this, true);
        document.addEventListener('mouseleave', this, true);
        document.addEventListener('mouseover', this, true);
        document.addEventListener('mouseout', this, true);
        document.addEventListener('keydown', this, true);
        document.addEventListener('keyup', this, true);
        document.addEventListener('keypress', this, true);
        document.addEventListener('contextmenu', this, true);
    }
    /**
     * Remove the document event listeners for the drag object.
     */
    _removeListeners() {
        document.removeEventListener('mousedown', this, true);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('mouseenter', this, true);
        document.removeEventListener('mouseleave', this, true);
        document.removeEventListener('mouseover', this, true);
        document.removeEventListener('mouseout', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('keyup', this, true);
        document.removeEventListener('keypress', this, true);
        document.removeEventListener('contextmenu', this, true);
    }
    /**
     * Update the drag scroll element under the mouse.
     */
    _updateDragScroll(event) {
        // Find the scroll target under the mouse.
        const target = Private.findScrollTarget(event, this);
        // Bail if there is nothing to scroll.
        if (!this._scrollTarget && !target) {
            return;
        }
        // Start the scroll loop if needed.
        if (!this._scrollTarget) {
            setTimeout(this._onScrollFrame, 500);
        }
        // Update the scroll target.
        this._scrollTarget = target;
    }
    /**
     * Update the current target node using the given mouse event.
     */
    _updateCurrentTarget(event) {
        // Fetch common local state.
        const prevTarget = this._currentTarget;
        let currTarget = this._currentTarget;
        const prevElem = this._currentElement;
        // Find the current indicated element at the given position.
        const currElems = document.elementsFromPoint(event.clientX + this._dragOffsetX, event.clientY + this._dragOffsetY);
        let currElem = currElems.find(elem => elem.classList.contains('pr-JupyterDashboard'));
        if (!currElem) {
            currElem = currElems[0];
        }
        // Update the current element reference.
        this._currentElement = currElem;
        // If the indicated element changes from the previous iteration,
        // and is different from the current target, dispatch the exit
        // event to the target.
        if (currElem !== prevElem && currElem !== currTarget) {
            Private.dispatchDragExit(this, currTarget, currElem, event);
        }
        // If the indicated element changes from the previous iteration,
        // and is different from the current target, dispatch the enter
        // event and compute the new target element.
        if (currElem !== prevElem && currElem !== currTarget) {
            currTarget = Private.dispatchDragEnter(this, currElem, currTarget, event);
        }
        // If the current target element has changed, update the current
        // target reference and dispatch the leave event to the old target.
        if (currTarget !== prevTarget) {
            this._currentTarget = currTarget;
            Private.dispatchDragLeave(this, prevTarget, currTarget, event);
        }
        // Dispatch the drag over event and update the drop action.
        const action = Private.dispatchDragOver(this, currTarget, event);
        this._setDropAction(action);
    }
    /**
     * Attach the drag image element at the specified location.
     *
     * This is a no-op if there is no drag image element.
     */
    _attachDragImage(clientX, clientY) {
        if (!this.dragImage) {
            return;
        }
        this.dragImage.classList.add('p-mod-drag-image');
        const style = this.dragImage.style;
        style.pointerEvents = 'none';
        style.position = 'fixed';
        style.top = `${clientY + this._dragOffsetY}px`;
        style.left = `${clientX + this._dragOffsetX}px`;
        document.body.appendChild(this.dragImage);
    }
    /**
     * Move the drag image element to the specified location.
     *
     * This is a no-op if there is no drag image element.
     */
    moveDragImage(clientX, clientY) {
        if (!this.dragImage) {
            return;
        }
        const style = this.dragImage.style;
        style.top = `${clientY + this.dragOffsetY}px`;
        style.left = `${clientX + this.dragOffsetX}px`;
    }
    /**
     * Detach the drag image element from the DOM.
     *
     * This is a no-op if there is no drag image element.
     */
    _detachDragImage() {
        if (!this.dragImage) {
            return;
        }
        const parent = this.dragImage.parentNode;
        if (!parent) {
            return;
        }
        parent.removeChild(this.dragImage);
    }
    /**
     * Set the internal drop action state and update the drag cursor.
     */
    _setDropAction(action) {
        action = Private.validateAction(action, this.supportedActions);
        if (this._override && this._dropAction === action) {
            return;
        }
        switch (action) {
            case 'none':
                this._dropAction = action;
                this._override = Drag.overrideCursor('no-drop');
                break;
            case 'copy':
                this._dropAction = action;
                this._override = Drag.overrideCursor('copy');
                break;
            case 'link':
                this._dropAction = action;
                this._override = Drag.overrideCursor('alias');
                break;
            case 'move':
                this._dropAction = action;
                this._override = Drag.overrideCursor('move');
                break;
        }
    }
    /**
     * Finalize the drag operation and resolve the drag promise.
     */
    _finalize(action) {
        // Store the resolve function as a temp variable.
        const resolve = this._resolve;
        // Remove the document event listeners.
        this._removeListeners();
        // Detach the drag image.
        this._detachDragImage();
        // Dispose of the cursor override.
        if (this._override) {
            this._override.dispose();
            this._override = null;
        }
        // Clear the mime data.
        this.mimeData.clear();
        // Clear the rest of the internal drag state.
        this._disposed = true;
        this._dropAction = 'none';
        this._currentTarget = null;
        this._currentElement = null;
        this._scrollTarget = null;
        this._promise = null;
        this._resolve = null;
        // Finally, resolve the promise to the given drop action.
        if (resolve) {
            resolve(action);
        }
    }
    /**
     * The scroll loop handler function.
     */
    _onScrollFrame = () => {
        // Bail early if there is no scroll target.
        if (!this._scrollTarget) {
            return;
        }
        // Unpack the scroll target.
        const { element, edge, distance } = this._scrollTarget;
        // Calculate the scroll delta using nonlinear acceleration.
        const d = Private.SCROLL_EDGE_SIZE - distance;
        const f = Math.pow(d / Private.SCROLL_EDGE_SIZE, 2);
        const s = Math.max(1, Math.round(f * Private.SCROLL_EDGE_SIZE));
        // Scroll the element in the specified direction.
        switch (edge) {
            case 'top':
                element.scrollTop -= s;
                break;
            case 'left':
                element.scrollLeft -= s;
                break;
            case 'right':
                element.scrollLeft += s;
                break;
            case 'bottom':
                element.scrollTop += s;
                break;
        }
        // Request the next cycle of the scroll loop.
        requestAnimationFrame(this._onScrollFrame);
    };
    get dragOffsetX() {
        return this._dragOffsetX;
    }
    get dragOffsetY() {
        return this._dragOffsetY;
    }
    _disposed = false;
    _dropAction = 'none';
    _override = null;
    _currentTarget = null;
    _currentElement = null;
    _promise = null;
    _scrollTarget = null;
    _resolve = null;
    _dragAdjustX;
    _dragAdjustY;
    _dragOffsetX = 0;
    _dragOffsetY = 0;
}
/**
 * The namespace for the `Drag` class statics.
 */
(function (Drag) {
    /**
     * Override the cursor icon for the entire document.
     *
     * @param cursor - The string representing the cursor style.
     *
     * @returns A disposable which will clear the override when disposed.
     *
     * #### Notes
     * The most recent call to `overrideCursor` takes precedence.
     * Disposing an old override has no effect on the current override.
     *
     * This utility function is used by the `Drag` class to override the
     * mouse cursor during a drag-drop operation, but it can also be used
     * by other classes to fix the cursor icon during normal mouse drags.
     *
     * #### Example
     * ```typescript
     * import { Drag } from '@lumino/dragdrop';
     *
     * // Force the cursor to be 'wait' for the entire document.
     * let override = Drag.overrideCursor('wait');
     *
     * // Clear the override by disposing the return value.
     * override.dispose();
     * ```
     */
    function overrideCursor(cursor) {
        const id = ++overrideCursorID;
        document.body.style.cursor = cursor;
        document.body.classList.add('p-mod-override-cursor');
        return new _lumino_disposable__WEBPACK_IMPORTED_MODULE_0__.DisposableDelegate(() => {
            if (id === overrideCursorID) {
                document.body.style.cursor = '';
                document.body.classList.remove('p-mod-override-cursor');
            }
        });
    }
    Drag.overrideCursor = overrideCursor;
    /**
     * The internal id for the active cursor override.
     */
    let overrideCursorID = 0;
})(Drag || (Drag = {}));
/**
 * The namespace for the module implementation details.
 */
var Private;
(function (Private) {
    /**
     * The size of a drag scroll edge, in pixels.
     */
    Private.SCROLL_EDGE_SIZE = 20;
    /**
     * Validate the given action is one of the supported actions.
     *
     * Returns the given action or `'none'` if the action is unsupported.
     */
    function validateAction(action, supported) {
        return actionTable[action] & supportedTable[supported] ? action : 'none';
    }
    Private.validateAction = validateAction;
    /**
     * Create a left mouse event at the given position.
     *
     * @param type - The event type for the mouse event.
     *
     * @param clientX - The client X position.
     *
     * @param clientY - The client Y position.
     *
     * @returns A newly created and initialized mouse event.
     */
    function createMouseEvent(type, clientX, clientY) {
        const event = document.createEvent('MouseEvent');
        event.initMouseEvent(type, true, true, window, 0, 0, 0, clientX, clientY, false, false, false, false, 0, null);
        return event;
    }
    Private.createMouseEvent = createMouseEvent;
    /**
     * Find the drag scroll target under the mouse, if any.
     */
    function findScrollTarget(event, drag) {
        // Look up the client mouse position.
        const x = event.clientX + drag.dragOffsetX;
        const y = event.clientY + drag.dragOffsetY;
        // Get the element under the mouse.
        let element = document.elementFromPoint(x, y);
        // Search for a scrollable target based on the mouse position.
        // The null assert in third clause of for-loop is required due to:
        // https://github.com/Microsoft/TypeScript/issues/14143
        for (; element; element = element.parentElement) {
            // Ignore elements which are not marked as scrollable.
            if (!element.hasAttribute('data-p-dragscroll')) {
                continue;
            }
            // Set up the coordinate offsets for the element.
            let offsetX = 0;
            let offsetY = 0;
            if (element === document.body) {
                offsetX = window.pageXOffset;
                offsetY = window.pageYOffset;
            }
            // Get the element bounds in viewport coordinates.
            const r = element.getBoundingClientRect();
            const top = r.top + offsetY;
            const left = r.left + offsetX;
            const right = left + r.width;
            const bottom = top + r.height;
            // Skip the element if it's not under the mouse.
            if (x < left || x >= right || y < top || y >= bottom) {
                continue;
            }
            // Compute the distance to each edge.
            const dl = x - left + 1;
            const dt = y - top + 1;
            const dr = right - x;
            const db = bottom - y;
            // Find the smallest of the edge distances.
            const distance = Math.min(dl, dt, dr, db);
            // Skip the element if the mouse is not within a scroll edge.
            if (distance > Private.SCROLL_EDGE_SIZE) {
                continue;
            }
            // Set up the edge result variable.
            let edge;
            // Find the edge for the computed distance.
            switch (distance) {
                case db:
                    edge = 'bottom';
                    break;
                case dt:
                    edge = 'top';
                    break;
                case dr:
                    edge = 'right';
                    break;
                case dl:
                    edge = 'left';
                    break;
                default:
                    throw 'unreachable';
            }
            // Compute how much the element can scroll in width and height.
            const dsw = element.scrollWidth - element.clientWidth;
            const dsh = element.scrollHeight - element.clientHeight;
            // Determine if the element should be scrolled for the edge.
            let shouldScroll;
            switch (edge) {
                case 'top':
                    shouldScroll = dsh > 0 && element.scrollTop > 0;
                    break;
                case 'left':
                    shouldScroll = dsw > 0 && element.scrollLeft > 0;
                    break;
                case 'right':
                    shouldScroll = dsw > 0 && element.scrollLeft < dsw;
                    break;
                case 'bottom':
                    shouldScroll = dsh > 0 && element.scrollTop < dsh;
                    break;
                default:
                    throw 'unreachable';
            }
            // Skip the element if it should not be scrolled.
            if (!shouldScroll) {
                continue;
            }
            // Return the drag scroll target.
            return { element, edge, distance };
        }
        // No drag scroll target was found.
        return null;
    }
    Private.findScrollTarget = findScrollTarget;
    /**
     * Dispatch a drag enter event to the indicated element.
     *
     * @param drag - The drag object associated with the action.
     *
     * @param currElem - The currently indicated element, or `null`. This
     *   is the "immediate user selection" from the whatwg spec.
     *
     * @param currTarget - The current drag target element, or `null`. This
     *   is the "current target element" from the whatwg spec.
     *
     * @param event - The mouse event related to the action.
     *
     * @returns The element to use as the current drag target. This is the
     *   "current target element" from the whatwg spec, and may be `null`.
     *
     * #### Notes
     * This largely implements the drag enter portion of the whatwg spec:
     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
     */
    function dispatchDragEnter(drag, currElem, currTarget, event) {
        // If the current element is null, return null as the new target.
        if (!currElem) {
            return null;
        }
        // Dispatch a drag enter event to the current element.
        let dragEvent = createDragEvent('lm-dragenter', drag, event, currTarget);
        const canceled = !currElem.dispatchEvent(dragEvent);
        // If the event was canceled, use the current element as the new target.
        if (canceled) {
            return currElem;
        }
        // If the current element is the document body, keep the original target.
        if (currElem === document.body) {
            return currTarget;
        }
        // Dispatch a drag enter event on the document body.
        dragEvent = createDragEvent('lm-dragenter', drag, event, currTarget);
        document.body.dispatchEvent(dragEvent);
        // Ignore the event cancellation, and use the body as the new target.
        return document.body;
    }
    Private.dispatchDragEnter = dispatchDragEnter;
    /**
     * Dispatch a drag exit event to the indicated element.
     *
     * @param drag - The drag object associated with the action.
     *
     * @param prevTarget - The previous target element, or `null`. This
     *   is the previous "current target element" from the whatwg spec.
     *
     * @param currTarget - The current drag target element, or `null`. This
     *   is the "current target element" from the whatwg spec.
     *
     * @param event - The mouse event related to the action.
     *
     * #### Notes
     * This largely implements the drag exit portion of the whatwg spec:
     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
     */
    function dispatchDragExit(drag, prevTarget, currTarget, event) {
        // If the previous target is null, do nothing.
        if (!prevTarget) {
            return;
        }
        // Dispatch the drag exit event to the previous target.
        const dragEvent = createDragEvent('lm-dragexit', drag, event, currTarget);
        prevTarget.dispatchEvent(dragEvent);
    }
    Private.dispatchDragExit = dispatchDragExit;
    /**
     * Dispatch a drag leave event to the indicated element.
     *
     * @param drag - The drag object associated with the action.
     *
     * @param prevTarget - The previous target element, or `null`. This
     *   is the previous "current target element" from the whatwg spec.
     *
     * @param currTarget - The current drag target element, or `null`. This
     *   is the "current target element" from the whatwg spec.
     *
     * @param event - The mouse event related to the action.
     *
     * #### Notes
     * This largely implements the drag leave portion of the whatwg spec:
     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
     */
    function dispatchDragLeave(drag, prevTarget, currTarget, event) {
        // If the previous target is null, do nothing.
        if (!prevTarget) {
            return;
        }
        // Dispatch the drag leave event to the previous target.
        const dragEvent = createDragEvent('lm-dragleave', drag, event, currTarget);
        prevTarget.dispatchEvent(dragEvent);
    }
    Private.dispatchDragLeave = dispatchDragLeave;
    /**
     * Dispatch a drag over event to the indicated element.
     *
     * @param drag - The drag object associated with the action.
     *
     * @param currTarget - The current drag target element, or `null`. This
     *   is the "current target element" from the whatwg spec.
     *
     * @param event - The mouse event related to the action.
     *
     * @returns The `DropAction` result of the drag over event.
     *
     * #### Notes
     * This largely implements the drag over portion of the whatwg spec:
     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
     */
    function dispatchDragOver(drag, currTarget, event) {
        // If there is no current target, the drop action is none.
        if (!currTarget) {
            return 'none';
        }
        // Dispatch the drag over event to the current target.
        const dragEvent = createDragEvent('lm-dragover', drag, event, null);
        const canceled = !currTarget.dispatchEvent(dragEvent);
        // If the event was canceled, return the drop action result.
        if (canceled) {
            return dragEvent.dropAction;
        }
        // Otherwise, the effective drop action is none.
        return 'none';
    }
    Private.dispatchDragOver = dispatchDragOver;
    /**
     * Dispatch a drop event to the indicated element.
     *
     * @param drag - The drag object associated with the action.
     *
     * @param currTarget - The current drag target element, or `null`. This
     *   is the "current target element" from the whatwg spec.
     *
     * @param event - The mouse event related to the action.
     *
     * @returns The `DropAction` result of the drop event.
     *
     * #### Notes
     * This largely implements the drag over portion of the whatwg spec:
     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model
     */
    function dispatchDrop(drag, currTarget, event) {
        // If there is no current target, the drop action is none.
        if (!currTarget) {
            return 'none';
        }
        // Dispatch the drop event to the current target.
        const dragEvent = createDragEvent('lm-drop', drag, event, null);
        const canceled = !currTarget.dispatchEvent(dragEvent);
        // If the event was canceled, return the drop action result.
        if (canceled) {
            return dragEvent.dropAction;
        }
        // Otherwise, the effective drop action is none.
        return 'none';
    }
    Private.dispatchDrop = dispatchDrop;
    /**
     * A lookup table from drop action to bit value.
     */
    const actionTable = {
        none: 0x0,
        copy: 0x1,
        link: 0x2,
        move: 0x4
    };
    /**
     * A lookup table from supported action to drop action bit mask.
     */
    const supportedTable = {
        none: actionTable['none'],
        copy: actionTable['copy'],
        link: actionTable['link'],
        move: actionTable['move'],
        'copy-link': actionTable['copy'] | actionTable['link'],
        'copy-move': actionTable['copy'] | actionTable['move'],
        'link-move': actionTable['link'] | actionTable['move'],
        all: actionTable['copy'] | actionTable['link'] | actionTable['move']
    };
    /**
     * Create a new initialized `IDragEvent` from the given data.
     *
     * @param type - The event type for the drag event.
     *
     * @param drag - The drag object to use for seeding the drag data.
     *
     * @param event - The mouse event to use for seeding the mouse data.
     *
     * @param related - The related target for the event, or `null`.
     *
     * @returns A new object which implements `IDragEvent`.
     */
    function createDragEvent(type, drag, event, related) {
        // Create a new mouse event to use as the drag event. Currently,
        // JS engines do now allow user-defined Event subclasses.
        const dragEvent = document.createEvent('MouseEvent');
        // Initialize the mouse event data.
        dragEvent.initMouseEvent(type, true, true, window, 0, event.screenX + drag.dragOffsetX, event.screenY + drag.dragOffsetY, event.clientX + drag.dragOffsetX, event.clientY + drag.dragOffsetY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, related);
        // Forcefully add the custom drag event properties.
        dragEvent.dropAction = 'none';
        dragEvent.mimeData = drag.mimeData;
        dragEvent.proposedAction = drag.proposedAction;
        dragEvent.supportedActions = drag.supportedActions;
        dragEvent.source = drag.source;
        // Return the fully initialized drag event.
        return dragEvent;
    }
})(Private || (Private = {}));


/***/ }),

/***/ "./lib/dashboard/icons.js":
/*!********************************!*\
  !*** ./lib/dashboard/icons.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashboardIcons": () => (/* binding */ DashboardIcons)
/* harmony export */ });
/* harmony import */ var _datalayer_icons_react_data1_DashboardOutlineWhiteIconLabIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @datalayer/icons-react/data1/DashboardOutlineWhiteIconLabIcon */ "../../../../icons/react/data1/esm/DashboardOutlineWhiteIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_DashboardGreyIconLabIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @datalayer/icons-react/data1/DashboardGreyIconLabIcon */ "../../../../icons/react/data1/esm/DashboardGreyIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_DashboardTealIconLabIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @datalayer/icons-react/data1/DashboardTealIconLabIcon */ "../../../../icons/react/data1/esm/DashboardTealIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_DashboardWhiteIconLabIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @datalayer/icons-react/data1/DashboardWhiteIconLabIcon */ "../../../../icons/react/data1/esm/DashboardWhiteIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_DragIndicatorIconLabIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @datalayer/icons-react/data1/DragIndicatorIconLabIcon */ "../../../../icons/react/data1/esm/DragIndicatorIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_DragIndicatorLinesIconLabIcon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @datalayer/icons-react/data1/DragIndicatorLinesIconLabIcon */ "../../../../icons/react/data1/esm/DragIndicatorLinesIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_EditIconLabIcon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @datalayer/icons-react/data1/EditIconLabIcon */ "../../../../icons/react/data1/esm/EditIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_FullscreenIconLabIcon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @datalayer/icons-react/data1/FullscreenIconLabIcon */ "../../../../icons/react/data1/esm/FullscreenIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_RedoIconLabIcon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @datalayer/icons-react/data1/RedoIconLabIcon */ "../../../../icons/react/data1/esm/RedoIconLabIcon.js");
/* harmony import */ var _datalayer_icons_react_data1_ViewIconLabIcon__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @datalayer/icons-react/data1/ViewIconLabIcon */ "../../../../icons/react/data1/esm/ViewIconLabIcon.js");












const DashboardIcons = {
    dashboardBlue: _datalayer_icons_react_data1_DashboardOutlineWhiteIconLabIcon__WEBPACK_IMPORTED_MODULE_0__["default"],
    dashboardGrey: _datalayer_icons_react_data1_DashboardGreyIconLabIcon__WEBPACK_IMPORTED_MODULE_1__["default"],
    dashboardGreyOutline: _datalayer_icons_react_data1_DashboardOutlineWhiteIconLabIcon__WEBPACK_IMPORTED_MODULE_0__["default"],
    dashboardTeal: _datalayer_icons_react_data1_DashboardTealIconLabIcon__WEBPACK_IMPORTED_MODULE_2__["default"],
    dashboardWhite: _datalayer_icons_react_data1_DashboardWhiteIconLabIcon__WEBPACK_IMPORTED_MODULE_3__["default"],
    dashboardWhiteOutline: _datalayer_icons_react_data1_DashboardOutlineWhiteIconLabIcon__WEBPACK_IMPORTED_MODULE_0__["default"],
    dragIndicator: _datalayer_icons_react_data1_DragIndicatorIconLabIcon__WEBPACK_IMPORTED_MODULE_4__["default"],
    dragIndicatorLines: _datalayer_icons_react_data1_DragIndicatorLinesIconLabIcon__WEBPACK_IMPORTED_MODULE_5__["default"],
    edit: _datalayer_icons_react_data1_EditIconLabIcon__WEBPACK_IMPORTED_MODULE_6__["default"],
    fullScreen: _datalayer_icons_react_data1_FullscreenIconLabIcon__WEBPACK_IMPORTED_MODULE_7__["default"],
    redo: _datalayer_icons_react_data1_RedoIconLabIcon__WEBPACK_IMPORTED_MODULE_8__["default"],
    view: _datalayer_icons_react_data1_ViewIconLabIcon__WEBPACK_IMPORTED_MODULE_9__["default"],
};


/***/ }),

/***/ "./lib/dashboard/layout.js":
/*!*********************************!*\
  !*** ./lib/dashboard/layout.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashboardLayout": () => (/* binding */ DashboardLayout)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/messaging */ "webpack/sharing/consume/default/@lumino/messaging");
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_3__);




/**
 * The class name added to the dashboard canvas.
 */
const CANVAS_CLASS = 'dsh-Canvas';
/**
 * The class name added to a dashboard in tiled mode.
 */
const TILED_LAYOUT_CLASS = 'dsh-TiledLayout';
/**
 * The class name added to a dashboard in free mode.
 */
const FREE_LAYOUT_CLASS = 'dsh-FreeLayout';
/**
 * A layout for dashboards.
 */
class DashboardLayout extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Layout {
    /**
     * Construct a dashboard layout.
     */
    constructor(options) {
        super(options);
        const { widgetStore, outputTracker, width, height, mode, model } = options;
        this._items = new Map();
        this._widgetStore = widgetStore;
        this._outputTracker = outputTracker;
        this._width = width || 0;
        this._height = height || 0;
        this._canvas = DashboardLayout.makeCanvas(this._width, this._height);
        if (mode === 'free-edit') {
            this._canvas.classList.add(FREE_LAYOUT_CLASS);
        }
        else if (mode === 'grid-edit') {
            this._canvas.classList.add(TILED_LAYOUT_CLASS);
        }
        this._mode = mode;
        model.stateChanged.connect(this._handleModelChange, this);
    }
    /**
     * Handles signals emitted by the underlying model.
     */
    _handleModelChange(_sender, change) {
        const { name, newValue } = change;
        switch (name) {
            case 'dashboardWidth':
                this.width = newValue;
                break;
            case 'dashboardHeight':
                this.height = newValue;
                break;
            case 'mode':
                this.setMode(newValue);
                break;
            default:
                break;
        }
    }
    /**
     * The canvas for the dashboard.
     */
    get canvas() {
        return this._canvas;
    }
    /**
     * Perform initilization that requires a parent.
     */
    init() {
        super.init();
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(this, widget => this.attachWidget(widget));
        this.parent.node.appendChild(this._canvas);
    }
    /**
     * Dispose of resources held by the layout.
     */
    dispose() {
        this._items.forEach(item => item.dispose());
        this._outputTracker = undefined;
        this._widgetStore = undefined;
        super.dispose();
    }
    /**
     * Handle `after-attach` messages for the layout.
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this._dashboard = this.parent;
        if (this.mode === 'grid-edit') {
            this.setTileSize(this.tileSize);
        }
    }
    /**
     * Create an iterator over the widgets in the layout.
     *
     * @override
     *
     * @returns a new iterator over the widgets in the layout.
     */
    iter() {
        // Is there a lazy way to iterate through the map?
        const arr = Array.from(this._items.values());
        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.map)(arr, item => item.widget);
    }
    [Symbol.iterator]() {
        const arr = Array.from(this._items.values());
        return (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.map)(arr, item => item.widget);
    }
    signalChange(change) {
        if (!this._signalChanges) {
            return;
        }
        if (change) {
            this._changes.push(change);
        }
        if (!this.inBatch) {
            this._changed.emit(this._changes);
            this._changes = [];
        }
    }
    /**
     * Attach a widget to the parent's DOM node.
     *
     * @param widget - The widget to attach to the parent.
     */
    attachWidget(widget) {
        // Set widget's parent.
        widget.parent = this.parent;
        // Send a `'before-attach'` message if the parent is attached.
        if (this.parent.isAttached) {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget.Msg.BeforeAttach);
        }
        // Add the widget's node to the parent.
        this.parent.node.appendChild(widget.node);
        // Send an `'after-attach'` message if the parent is attached.
        if (this.parent.isAttached) {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget.Msg.AfterAttach);
        }
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
    /**
     * Detach a widget from the parent's DOM node.
     *
     * @param widget - The widget to detach from the parent.
     */
    detachWidget(_index, widget) {
        // Send a `'before-detach'` message if the parent is attached.
        if (this.parent.isAttached) {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget.Msg.BeforeDetach);
        }
        // Remove the widget's node from the parent.
        this.parent.node.removeChild(widget.node);
        // Send an `'after-detach'` message if the parent is attached.
        if (this.parent.isAttached) {
            _lumino_messaging__WEBPACK_IMPORTED_MODULE_2__.MessageLoop.sendMessage(widget, _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget.Msg.AfterDetach);
        }
        widget.parent = null;
        // Post a fit request for the parent widget.
        this.parent.fit();
    }
    /**
     * Add a widget to the layout.
     *
     * @param widget - the widget to add.
     *
     * @param _pos - the desired size/position of the added widget.
     */
    addWidget(widget, _pos) {
        this.startBatch();
        this._addWidget(widget, _pos);
    }
    /**
     * A helper function to add a widget to the layout.
     *
     * @param widget - the widget to add.
     *
     * @param _pos - the desired size/position of the added widget.
     *
     * ### Notes
     * This method is called recursively to handle overlapping widgets and
     * shoudn't be called directly. If you want to add a widget, use the
     * .addWidget() method instead.
     */
    _addWidget(widget, _pos) {
        // Add the widget to the layout.
        const item = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.LayoutItem(widget);
        this._items.set(widget.id, item);
        // Attach the widget to the parent.
        if (this.parent) {
            if (this._dashboard !== undefined) {
                widget.mode = this._dashboard.model.mode;
            }
            else {
                widget.mode = 'present';
            }
            this.attachWidget(widget);
            const { id, notebookId, cellId } = widget;
            const ignore = !this._signalChanges;
            widget.ready.connect(() => {
                this._updateWidget(widget, widget.pos, false);
                this.fixOverlaps(widget);
                this._outputTracker.add(widget);
                const change = {
                    type: 'add',
                    pos: widget.pos,
                    widgetId: id,
                    notebookId,
                    cellId,
                    ignore
                };
                this.signalChange(change);
                this.endBatch();
            });
        }
    }
    /**
     * Move or resize a widget in the layout.
     *
     * @param widget - the widget to update.
     *
     * @param pos - the new position/size for the widget.
     *
     * @returns - whether the update was successful.
     */
    updateWidget(widget, pos) {
        const wasInBatch = this.inBatch;
        if (!wasInBatch) {
            this.startBatch();
        }
        const success = this._updateWidgetHelper(widget, pos);
        if (!wasInBatch) {
            this.endBatch();
        }
        return success;
    }
    /**
     * A helper function to move or resize a widget in the layout.
     *
     * @param widget - the widget to update.
     *
     * @param pos - the new position/size for the widget.
     *
     * @param fixOverlaps - whether overlaps should be automatically resolved.
     *
     * @returns - whether the update was successful.
     *
     * ### Notes
     * This is a helper function for the .updateWidget() method and should not
     * be called directly. Use .updateWidget() if you want to move or resize a
     * widget.
     */
    _updateWidgetHelper(widget, pos, fixOverlaps = true) {
        const success = this._updateWidget(widget, pos, fixOverlaps);
        if (success) {
            const change = {
                type: 'move',
                widgetId: widget.id,
                pos: widget.pos
            };
            this.signalChange(change);
        }
        return success;
    }
    /**
     * A helper function to move or resize a widget in the layout.
     *
     * @param widget - the widget to update.
     *
     * @param pos - the new position/size for the widget.
     *
     * @param fixOverlaps - whether overlaps should be automatically resolved.
     *
     * @returns - whether the update was successful.
     *
     * ### Notes
     * This function is called recursively to handle overlapping widgets and
     * shouldn't be called directly. If you want to update a widget, use
     * .updateWidget() instead.
     */
    _updateWidget(widget, pos, fixOverlaps = true) {
        // Get the item from the map.
        const item = this._items.get(widget.id);
        // If the item doesn't exist, return.
        if (item === undefined) {
            return false;
        }
        let { left, top, width, height } = pos;
        // Constrain the widget to the dashboard dimensions.
        if (this._width !== 0 && left + width > this._width) {
            left = this._width - width;
        }
        if (this._height !== 0 && top + height > this._height) {
            top = this._height - height;
        }
        // Prevent clipping on the top or left edge.
        left = Math.max(left, 0);
        top = Math.max(top, 0);
        // Snap to grid if in grid mode.
        if (widget.mode === 'grid-edit') {
            left = Private.mround(left, this._tileSize);
            top = Private.mround(top, this._tileSize);
            width = Math.max(Private.mround(width, this._tileSize), this._tileSize);
            height = Math.max(Private.mround(height, this._tileSize), this._tileSize);
            // Change width/height now to force grid changes if they're small.
            item.update(0, 0, 0, 0);
        }
        this.clearCanvas();
        item.update(left, top, width, height);
        if (fixOverlaps) {
            this.fixOverlaps(widget);
        }
        return true;
    }
    /**
     * Remove a widget from the layout.
     *
     * @param widget - the widget to remove.
     *
     * ### Notes
     * This is basically the same as deleteWidget but fulfills the type
     * signature requirements of the extended class.
     */
    removeWidget(widget) {
        void this.deleteWidget(widget);
    }
    /**
     * Remove a widget from the layout.
     *
     * @param widget - the widget to remove.
     */
    deleteWidget(widget) {
        // Look up the widget in the _items map.
        const item = this._items.get(widget.id);
        // Bail if it's not there.
        if (item === undefined) {
            return false;
        }
        const change = {
            type: 'remove',
            widgetId: widget.id
        };
        // Remove the item from the map.
        this._items.delete(widget.id);
        // Detach the widget from the parent.
        if (this.parent) {
            this.detachWidget(-1, widget);
        }
        this.clearCanvas();
        // Dispose the layout item.
        item.dispose();
        this.signalChange(change);
        return true;
    }
    /**
     * Adds a dashboard widget's information to the widgetStore.
     *
     * @param info - the information to add to the widgetStore.
     */
    updateWidgetInfo(info) {
        this._widgetStore?.addWidget(info);
    }
    /**
     * Mark a widget as deleted in the widgetStore.
     *
     * @param widget - the widget to mark as deleted.
     */
    deleteWidgetInfo(widget) {
        this._widgetStore?.deleteWidget(widget.id);
    }
    /**
     * Update a widgetStore entry for a widget given that widget.
     *
     * @param widget - the widget to update from.
     */
    updateInfoFromWidget(widget) {
        this.updateWidgetInfo(widget.info);
    }
    /**
     * Update the layout from a widgetStore record.
     *
     * @param record - the record to update from.
     */
    _updateLayoutFromRecord(record) {
        const item = this._items.get(record.widgetId);
        const pos = record.pos;
        if (record.widgetId === '') {
            // Widget has already been removed; ignore.
            if (item === undefined) {
                return;
            }
            // Widget is empty; remove.
            this.deleteWidget(item.widget);
        }
        else if (item === undefined) {
            // Widget has already been removed; ignore.
            if (record.removed) {
                return;
            }
            else {
                // Widget is newly added or undeleted; add.
                const newWidget = this._widgetStore?.createWidget(record);
                this.addWidget(newWidget, pos);
            }
        }
        else {
            // Widget was just removed; delete.
            if (record.removed) {
                this.deleteWidget(item.widget);
            }
            // Widget was moved or resized; update.
            this.updateWidget(item.widget, pos);
        }
    }
    /**
     * Updates the layout based on the state of the datastore.
     */
    updateLayoutFromWidgetStore() {
        this._signalChanges = false;
        const records = this._widgetStore?.getWidgets();
        Array.from(records).map(record => {
            this._updateLayoutFromRecord(record);
        });
        this._signalChanges = true;
    }
    /**
     * Undo the last change to the layout.
     */
    undo() {
        this.updateLayoutFromWidgetStore();
    }
    /**
     * Redo the last change to the layout.
     */
    redo() {
        this.updateLayoutFromWidgetStore();
    }
    /**
     * Gets an iterator of widgets overlapping a point.
     *
     * @param left - the distance from the point to the left edge of the dashboard.
     *
     * @param top - the distance from the point to the top edge of the dashboard.
     *
     * @returns - an iterator containing widgets at the point.
     */
    widgetsAtPoint(left, top) {
        const pos = {
            left,
            top,
            width: 0,
            height: 0
        };
        return this._widgetsInSelection(pos);
    }
    /**
     * Gets an iterator of widgets overlapping a selection
     *
     * @param pos - an object containing the left, top, width, and height
     * of the selection.
     *
     * @returns - an iterator containing widgets in that selection.
     */
    _widgetsInSelection(pos) {
        const relations = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.map)(this, _widget => {
            const widget = _widget;
            return widget.overlaps(pos);
        });
        const overlaps = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.filter)(relations, relation => relation.type !== 'none' && !relation.widget.locked);
        return overlaps;
    }
    /**
     * Resolve an overlap between two widgets.
     *
     * @param pos - the dimensions/position of the widget being overlapped.
     *
     * @param overlap - an object containing the overlapping widget and its position
     * relative to the underlying widget.
     */
    _handleOverlap(pos, overlap) {
        const { left, top, width, height } = pos;
        const { widget, type } = overlap;
        const newPos = widget.pos;
        let adjust;
        switch (type) {
            case 'up':
                newPos.top = top - newPos.height;
                break;
            case 'down':
                newPos.top = top + height;
                break;
            case 'left':
                newPos.left = left - newPos.width;
                break;
            case 'right':
                newPos.left = left + width;
                break;
        }
        if (newPos.left < 0) {
            adjust = Math.abs(newPos.left);
            newPos.left = 0;
            this._expandCanvas(type, adjust);
        }
        if (newPos.top < 0) {
            adjust = Math.abs(newPos.top);
            newPos.top = 0;
            this._expandCanvas(type, adjust);
        }
        const heightDiff = newPos.top + newPos.height - this.height;
        if (heightDiff > 0) {
            this._expandCanvas(type, heightDiff);
        }
        const widthDiff = newPos.left + newPos.width - this.width;
        if (widthDiff > 0) {
            this._expandCanvas(type, widthDiff);
        }
        this._updateWidget(widget, newPos);
    }
    /**
     * Resolves overlaps between several widgets.
     *
     * @param overlaps - an iterator containing information about widget overlaps.
     *
     * @param pos - the dimensions/position of the widget being overlapped.
     */
    handleOverlaps(overlaps, pos) {
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(overlaps, overlap => void this._handleOverlap(pos, overlap));
    }
    /**
     * Moves all widgets overlapping a selected widget.
     *
     * @param widget - the widget being overlapped.
     */
    fixOverlaps(widget) {
        const overlaps = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.filter)(this._widgetsInSelection(widget.pos), overlap => overlap.widget !== widget);
        widget.locked = true;
        this.handleOverlaps(overlaps, widget.pos);
        widget.locked = false;
    }
    /**
     * Increase the width/height of the dashboard canvas and automatically move
     * its widgets to accommodate the increase if necessary.
     *
     * @param direction - the direction to expand the canvas (left, right, up, down)
     *
     * @param amount - the number of pixels to expand the canvas.
     */
    _expandCanvas(direction, amount) {
        const model = this.parent.model;
        const widgets = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.toArray)(this);
        switch (direction) {
            case 'left':
                model.height += amount;
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(widgets, _widget => {
                    const widget = _widget;
                    const pos = widget.pos;
                    pos.left += amount;
                    this._updateWidgetHelper(widget, pos);
                });
                break;
            case 'right':
                model.width += amount;
                break;
            case 'up':
                model.height += amount;
                (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(widgets, _widget => {
                    const widget = _widget;
                    const pos = widget.pos;
                    pos.top += amount;
                    this._updateWidgetHelper(widget, pos);
                });
                break;
            case 'down':
                model.height += amount;
                break;
        }
    }
    /**
     * The width of the dashboard in pixels.
     */
    get width() {
        return this._width;
    }
    set width(newWidth) {
        if (newWidth < 0) {
            newWidth = 0;
        }
        this._width = newWidth;
        this._canvas.width = newWidth;
    }
    /**
     * The height of the dashboard in pixels.
     */
    get height() {
        return this._height;
    }
    set height(newHeight) {
        if (newHeight < 0) {
            newHeight = 0;
        }
        this._height = newHeight;
        this._canvas.height = newHeight;
    }
    /**
     * Set the dashboard display mode.
     *
     * @param newMode - the new mode (present, free, or tile).
     */
    setMode(newMode) {
        this._mode = newMode;
        this.clearCanvas();
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(this, _widget => {
            const widget = _widget;
            widget.mode = newMode;
        });
        switch (newMode) {
            case 'present':
                this.canvas.style.backgroundPosition = '';
                this.canvas.style.backgroundSize = '';
                this._canvas.classList.remove(FREE_LAYOUT_CLASS);
                this._canvas.classList.remove(TILED_LAYOUT_CLASS);
                break;
            case 'free-edit':
                this.canvas.style.backgroundPosition = '';
                this.canvas.style.backgroundSize = '';
                this._canvas.classList.remove(TILED_LAYOUT_CLASS);
                this._canvas.classList.add(FREE_LAYOUT_CLASS);
                break;
            case 'grid-edit':
                this.setTileSize(this._tileSize);
                this._canvas.classList.remove(FREE_LAYOUT_CLASS);
                this.canvas.classList.add(TILED_LAYOUT_CLASS);
                break;
        }
    }
    /**
     * The display mode for the dashboard (present, free, or tile).
     */
    get mode() {
        return this._mode;
    }
    /**
     * Start a batch of widget updates.
     */
    startBatch() {
        this._inBatch = true;
    }
    /**
     * End a batch of widget updates.
     *
     * ### Notes
     * If startBatch() was called before endBatch(), this will signal all
     * of the batched updates.
     */
    endBatch() {
        const wasInBatch = this.inBatch;
        this._inBatch = false;
        if (wasInBatch) {
            this.signalChange();
        }
    }
    /**
     * Whether the layout is in a batch of widget updates.
     */
    get inBatch() {
        return this._inBatch;
    }
    /**
     * Creates a dashboard widget from a widgetinfo object.
     *
     * @param info - info to create widget from.
     *
     * @param fit - whether to fit the widget to content when it's created.
     *
     * @returns - the created widget.
     *
     * @throws - an error if a notebook or cell isn't found from the ids in the
     * widgetinfo object.
     */
    createWidget(info, fit) {
        return this._widgetStore.createWidget(info, fit);
    }
    /**
     * A signal emitted when the layout changes.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Clear the layout's canvas.
     *
     * @returns a 2D context for the canvas.
     */
    clearCanvas() {
        const canvas = this.canvas;
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        return context;
    }
    /**
     * Draw a rectangle on the canvas.
     *
     * @param pos - the location and size of the rectangle.
     *
     * @param color - the color of the rectangle.
     */
    drawDropZone(pos, color) {
        const context = this.clearCanvas();
        context.setLineDash([5]);
        context.strokeStyle = color;
        context.fillStyle = `${color}66`;
        let { left, top, width, height } = pos;
        if (this.mode === 'grid-edit') {
            width = Math.max(Private.mround(width, this._tileSize), this._tileSize);
            height = Math.max(Private.mround(height, this._tileSize), this._tileSize);
            left = Private.mround(left, this._tileSize);
            top = Private.mround(top, this._tileSize);
        }
        context.strokeRect(left, top, width, height);
        context.fillRect(left, top, width, height);
    }
    /**
     * Sets the size of a single tile in tile layout model.
     *
     * @param s - the new tile size in pixels.
     */
    setTileSize(s) {
        this._tileSize = s;
        // const backgroundPosition = `0 0, 0 ${s}px, ${s}px -${s}px, -${s}px 0px`;
        // this.canvas.style.backgroundPosition = backgroundPosition;
        this.canvas.style.backgroundSize = `${s}px ${s}px`;
        this.parent.update();
        this.startBatch();
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(this, _widget => {
            const widget = _widget;
            this.updateWidget(widget, widget.pos);
        });
        this.endBatch();
    }
    /**
     * The size of a single tile layout tile in pixels.
     */
    get tileSize() {
        return this._tileSize;
    }
    /**
     * Reduces the dimensions of the dashboard to the minimum required to
     * contain all the widgets ("trims" excess dashboard to the right and
     * bottom of the content).
     */
    trimDashboard() {
        const model = this.parent.model;
        let maxWidth = 0;
        let maxHeight = 0;
        (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.each)(this, _widget => {
            const widget = _widget;
            const { left, top, width, height } = widget.pos;
            if (left + width > maxWidth) {
                maxWidth = left + width;
            }
            if (top + height > maxHeight) {
                maxHeight = top + height;
            }
        });
        if (maxWidth) {
            model.width = maxWidth;
        }
        if (maxHeight) {
            model.height = maxHeight;
        }
    }
    // Map from widget ids to LayoutItems
    _items;
    // Datastore widgets are rendered from / saved to.
    _widgetStore;
    // Output tracker to add new widgets to.
    _outputTracker;
    // Dummy canvas element to set dimensions of dashboard.
    _canvas;
    // Dashboard width (zero if unconstrained).
    _width;
    // Dashboard height (zero if unconstrained).
    _height;
    // Mode (either interactive or edit);
    _mode;
    // Parent dashboard.
    _dashboard;
    // Size of a single tile in tiled layout in pixels.
    _tileSize = DashboardLayout.DEFAULT_TILE_SIZE;
    // Changed signal
    _changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_3__.Signal(this);
    // An array of changes emitted when a single change or a batch finishes.
    _changes = [];
    // Whether the layout is currently in a batch of changes.
    _inBatch = false;
    // Whether the layout should emit the array of changes after a change or
    // batch finishes.
    _signalChanges = true;
}
/**
 * The namespace for the `DashboardLayout` class statics.
 */
(function (DashboardLayout) {
    /**
     * An options object for initializing a Dashboard layout.
     */
    /**
     * Create a widget to put in the canvas of a layout to set the length/width.
     *
     * @param x - width.
     *
     * @param y - height.
     */
    function makeCanvas(x, y) {
        const canvas = document.createElement('canvas');
        canvas.width = x;
        canvas.height = y;
        canvas.style.left = '0';
        canvas.style.top = '0';
        canvas.style.position = 'absolute';
        canvas.classList.add(CANVAS_CLASS);
        return canvas;
    }
    DashboardLayout.makeCanvas = makeCanvas;
    /**
     * The default size of a single tile in tiled layout.
     */
    DashboardLayout.DEFAULT_TILE_SIZE = 32;
})(DashboardLayout || (DashboardLayout = {}));
/**
 * A namespace for private functionality
 */
var Private;
(function (Private) {
    /**
     * Rounds `num` to the nearest integer multiple of `roundTo`.
     */
    function mround(num, roundTo) {
        return roundTo * Math.round(num / roundTo);
    }
    Private.mround = mround;
})(Private || (Private = {}));


/***/ }),

/***/ "./lib/dashboard/model.js":
/*!********************************!*\
  !*** ./lib/dashboard/model.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashboardModel": () => (/* binding */ DashboardModel),
/* harmony export */   "DashboardModelFactory": () => (/* binding */ DashboardModelFactory)
/* harmony export */ });
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/coreutils */ "webpack/sharing/consume/default/@jupyterlab/coreutils");
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/docregistry */ "webpack/sharing/consume/default/@jupyterlab/docregistry");
/* harmony import */ var _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/services */ "webpack/sharing/consume/default/@jupyterlab/services");
/* harmony import */ var _jupyterlab_services__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_services__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/observables */ "webpack/sharing/consume/default/@jupyterlab/observables");
/* harmony import */ var _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_observables__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./content */ "./lib/dashboard/content.js");
/* harmony import */ var _widgetStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./widgetStore */ "./lib/dashboard/widgetStore.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils */ "./lib/dashboard/utils.js");
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widget */ "./lib/dashboard/widget.js");









/**
 * An implementation of a dashboard Model.
 */
class DashboardModel extends _jupyterlab_docregistry__WEBPACK_IMPORTED_MODULE_2__.DocumentModel {
    /**
     * Construct a new dashboard model.
     */
    constructor(options) {
        super(options);
        const notebookTracker = (this.notebookTracker = options.notebookTracker);
        if (options.widgetStore !== undefined) {
            this.widgetStore = options.widgetStore;
            this._restore = true;
        }
        else {
            this.widgetStore = new _widgetStore__WEBPACK_IMPORTED_MODULE_5__.WidgetStore({ id: 0, notebookTracker });
        }
        this.contentsManager = options.contentsManager || new _jupyterlab_services__WEBPACK_IMPORTED_MODULE_3__.ContentsManager();
    }
    /**
     * Deserialize the model from JSON.
     */
    async fromJSON(value) {
        // A widgetStore has been supplied and the dashboard is ready to be populated.
        if (this._restore) {
            this._loaded.emit(void 0);
        }
        const outputs = [];
        for (const [_path, notebookId] of Object.entries(value.paths)) {
            const path = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.PathExt.resolve(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.PathExt.dirname(this.path), _path);
            if (!(0,_utils__WEBPACK_IMPORTED_MODULE_6__.getNotebookById)(notebookId, this.notebookTracker)) {
                await this.contentsManager
                    .get(path)
                    .then(async (model) => {
                    // no-op for now. Open notebook in future.
                })
                    .catch(error => {
                    throw new Error(`Error reading notebook ${notebookId} at ${path}`);
                });
            }
        }
        for (const [notebookId, notebookOutputs] of Object.entries(value.outputs)) {
            for (const outputInfo of notebookOutputs) {
                const info = {
                    ...outputInfo,
                    notebookId,
                    widgetId: _widget__WEBPACK_IMPORTED_MODULE_7__.DashboardWidget.createDashboardWidgetId()
                };
                outputs.push(info);
            }
        }
        this._metadata.clear();
        const metadata = value.metadata;
        for (const [key, value] of Object.entries(metadata)) {
            this._setMetadataProperty(key, value);
        }
        this.widgetStore.clear();
        outputs.forEach(output => {
            this.widgetStore.addWidget(output);
        });
        this._loaded.emit(void 0);
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        const notebookTracker = this.notebookTracker;
        // Get all widgets that haven't been removed.
        const records = this.widgetStore.getWidgets();
        const metadata = {
            name: this.name,
            dashboardHeight: this.height,
            dashboardWidth: this.width
        };
        const file = {
            metadata,
            version: _content__WEBPACK_IMPORTED_MODULE_8__.DASHBOARD_VERSION,
            outputs: {},
            paths: {}
        };
        for (let record of records) {
            const notebookId = record.notebookId;
            const _path = (0,_utils__WEBPACK_IMPORTED_MODULE_6__.getPathFromNotebookId)(notebookId, notebookTracker);
            if (_path === undefined) {
                throw new Error(`Notebook path for notebook with id ${notebookId} not found`);
            }
            const path = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.PathExt.relative(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.PathExt.dirname(this.path), _path);
            if (file.paths[path] !== undefined && file.paths[path] !== notebookId) {
                throw new Error(`Conflicting paths for same notebook id ${notebookId}`);
            }
            file.paths[path] = notebookId;
            if (file.outputs[notebookId] === undefined) {
                file.outputs[notebookId] = [];
            }
            const outputInfo = {
                cellId: record.cellId,
                pos: record.pos
            };
            file.outputs[notebookId].push(outputInfo);
        }
        ;
        return file;
    }
    /**
     * Serialize the model to a string.
     */
    toString() {
        return JSON.stringify(this.toJSON(), undefined, 2);
    }
    /**
     * Deserialize the model from a string.
     */
    async fromString(value) {
        if (!value) {
            this._loaded.emit(void 0);
            return;
        }
        const json = JSON.parse(value);
        return this.fromJSON(json);
    }
    initialize() {
        // no-op
    }
    /**
     * The display mode of the dashboard.
     */
    get mode() {
        return this._mode;
    }
    set mode(newValue) {
        const oldValue = this._mode;
        if (oldValue === newValue) {
            return;
        }
        this._mode = newValue;
        this.triggerStateChange({ name: 'mode', oldValue, newValue });
    }
    /**
     * The metadata associated with the dashboard;
     */
    get metadata() {
        return this._metadata;
    }
    /**
     * The name of the dashboard.
     *
     * ### Development notes
     * This may be redundant with the filename and could be removed.
     */
    get name() {
        return this.metadata.get('name');
    }
    set name(newValue) {
        this._setMetadataProperty('name', newValue);
    }
    /**
     * The width of the dashboard in pixels.
     */
    get width() {
        return +(this.metadata.get('dashboardWidth') || 0);
    }
    set width(newValue) {
        this._setMetadataProperty('dashboardWidth', newValue);
    }
    /**
     * The height of the dashboard in pixels.
     */
    get height() {
        return +(this.metadata.get('dashboardHeight') || 0);
    }
    set height(newValue) {
        this._setMetadataProperty('dashboardHeight', newValue);
    }
    /**
     * Sets a key in the metadata and emits the change as a signal.
     *
     * @param key - the key to change in the metadata.
     *
     * @param newValue - the new value to set the key to.
     *
     * ### Notes
     * No signal is emitted if newValue is the same as the old value.
     */
    _setMetadataProperty(key, newValue) {
        const oldValue = this.metadata.get(key);
        if (oldValue === newValue) {
            return;
        }
        this.metadata.set(key, newValue);
        this.triggerStateChange({ name: key, oldValue, newValue });
    }
    /**
     * A signal emitted when the dashboard is done being deserialized.
     */
    get loaded() {
        return this._loaded;
    }
    /**
     * The scroll mode of the dashboard.
     */
    get scrollMode() {
        return this._scrollMode;
    }
    set scrollMode(newValue) {
        this._scrollMode = newValue;
    }
    /**
     * The current path associated with the model.
     */
    get path() {
        return this._path;
    }
    set path(newPath) {
        this._path = newPath;
    }
    /**
     * The widget store for the dashboard.
     */
    widgetStore;
    /**
     * The notebook tracker for the dashboard.
     */
    notebookTracker;
    /**
     * The contents manager for the dashboard.
     */
    contentsManager;
    _metadata = new _jupyterlab_observables__WEBPACK_IMPORTED_MODULE_4__.ObservableJSON();
    _loaded = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_0__.Signal(this);
    _mode = 'grid-edit';
    _scrollMode = 'constrained';
    _path = '';
    _restore = false;
}
/**
 * A factory class for dashboard models.
 */
class DashboardModelFactory {
    /**
     * Construct a new dashboard model factory.
     */
    constructor(options) {
        this._notebookTracker = options.notebookTracker;
    }
    /**
     * Whether the model factory is disposed.
     */
    get isDisposed() {
        return this._disposed;
    }
    /**
     * Dispose of the resources held by the model factory.
     */
    dispose() {
        this._disposed = true;
    }
    /**
     * The format of the file.
     */
    get fileFormat() {
        return 'text';
    }
    /**
     * The name of the model.
     */
    get name() {
        return 'dashboard';
    }
    /**
     * The content type of the file.
     */
    get contentType() {
        return 'file';
    }
    /**
     * Get the preferred kernel langauge given a path (currently a no-op).
     */
    preferredLanguage(path) {
        return '';
    }
    /**
     * Create a new model for a given path.
     */
    createNew(options) {
        const notebookTracker = this._notebookTracker;
        const contentsManager = new _jupyterlab_services__WEBPACK_IMPORTED_MODULE_3__.ContentsManager();
        const model = new DashboardModel({
            notebookTracker,
            contentsManager
        });
        return model;
    }
    _disposed = false;
    _notebookTracker;
}


/***/ }),

/***/ "./lib/dashboard/utils.js":
/*!********************************!*\
  !*** ./lib/dashboard/utils.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addCellId": () => (/* binding */ addCellId),
/* harmony export */   "addNotebookId": () => (/* binding */ addNotebookId),
/* harmony export */   "getCellById": () => (/* binding */ getCellById),
/* harmony export */   "getCellId": () => (/* binding */ getCellId),
/* harmony export */   "getMetadata": () => (/* binding */ getMetadata),
/* harmony export */   "getNotebookById": () => (/* binding */ getNotebookById),
/* harmony export */   "getNotebookId": () => (/* binding */ getNotebookId),
/* harmony export */   "getPathFromNotebookId": () => (/* binding */ getPathFromNotebookId),
/* harmony export */   "updateMetadata": () => (/* binding */ updateMetadata)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__);


/**
 * Gets the presto metadata portion of a notebook or cell.
 *
 * @param source - the notebook or cell containing the metadata.
 */
function getMetadata(source) {
    return source.model?.getMetadata('presto');
}
function updateMetadata(source, newValues) {
    const oldMetadata = getMetadata(source);
    if (oldMetadata != null) {
        source.model?.setMetadata('presto', { ...oldMetadata, ...newValues });
    }
    else {
        source.model?.setMetadata('presto', newValues);
    }
}
/**
 * Adds a random, unique ID to a notebook's metadata.
 *
 * @param notebook - the notebook to add an ID to.
 *
 * @returns - the notebook's ID.
 */
function addNotebookId(notebook) {
    const metadata = getMetadata(notebook);
    let id;
    if (metadata !== undefined) {
        if (metadata.id !== undefined) {
            return metadata.id;
        }
        id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4();
        notebook.model?.setMetadata('presto', { ...metadata, id });
    }
    else {
        id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4();
        notebook.model?.setMetadata('presto', { id });
    }
    return id;
}
/**
 * Gets the unique ID of a notebook.
 *
 * @returns - the ID of the notebook, or undefined if it has none.
 */
function getNotebookId(notebook) {
    const metadata = getMetadata(notebook);
    if (metadata === undefined || metadata.id === undefined) {
        return undefined;
    }
    return metadata.id;
}
/**
 * Gets a notebook given its ID.
 *
 * @param id - the ID of the notebook to retrieve.
 *
 * @param tracker - the notebook tracker to search for the notebook in.
 *
 * @returns - the Notebook, or undefined if no notebook with that ID exists.
 */
function getNotebookById(id, tracker) {
    return tracker.find(notebook => getNotebookId(notebook) === id);
}
/**
 * Adds a random, unique ID to a notebook cell's metadata.
 *
 * @param notebook - the cell to add an ID to.
 *
 * @returns - the cell's ID.
 */
function addCellId(cell) {
    const metadata = getMetadata(cell);
    let id;
    if (metadata !== undefined) {
        if (metadata.id !== undefined) {
            return metadata.id;
        }
        id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4();
        cell.model.setMetadata('presto', { ...metadata, id });
    }
    else {
        id = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4();
        cell.model.setMetadata('presto', { id });
    }
    return id;
}
/**
 * Gets the unique ID of a cell.
 *
 * @returns - the ID of the cell, or undefined if it has none.
 */
function getCellId(cell) {
    const metadata = getMetadata(cell);
    if (metadata === undefined || metadata.id === undefined) {
        return undefined;
    }
    return metadata.id;
}
/**
 * Gets a cell given its ID.
 *
 * @param id - the ID of the cell to retrieve.
 *
 * @param tracker - the notebook tracker to search for the cell in.
 *
 * @returns - the Cell, or undefined if no cell with that ID exists.
 */
function getCellById(id, tracker) {
    const notebooks = (0,_lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.toArray)(tracker.filter(() => true));
    for (const notebook of notebooks) {
        const cells = notebook.content.widgets;
        const value = _lumino_algorithm__WEBPACK_IMPORTED_MODULE_1__.ArrayExt.findFirstValue(cells, cell => getCellId(cell) === id);
        if (value !== undefined) {
            return value;
        }
    }
    return undefined;
}
/**
 * Gets the path to a notebook given its ID.
 *
 * @param id - the ID of the notebook whose path is desired.
 *
 * @param notebookTracker - the notebook tracker to search for the notebook in.
 *
 * @returns - the path to the notebook, or undefined if it doesn't exist.
 */
function getPathFromNotebookId(id, notebookTracker) {
    const notebook = notebookTracker.find(notebook => getNotebookId(notebook) === id);
    if (notebook === undefined) {
        return undefined;
    }
    return notebook.context.path;
}


/***/ }),

/***/ "./lib/dashboard/widget.js":
/*!*********************************!*\
  !*** ./lib/dashboard/widget.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DashboardWidget": () => (/* binding */ DashboardWidget),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/messaging */ "webpack/sharing/consume/default/@lumino/messaging");
/* harmony import */ var _lumino_messaging__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_messaging__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lumino/algorithm */ "webpack/sharing/consume/default/@lumino/algorithm");
/* harmony import */ var _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./drag */ "./lib/dashboard/drag.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ "./lib/dashboard/utils.js");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_4__);







/**
 * The class name added to dashboard outputs
 */
const DASHBOARD_WIDGET_CLASS = 'dsh-DashboardWidget';
/**
 * The class name for the widget drag mime.
 */
const DASHBOARD_WIDGET_MIME = 'dsh-DashboardWidgetMine';
/**
 * The class name added to the children of dashboard outputs.
 */
const DASHBOARD_WIDGET_CHILD_CLASS = 'dsh-DashboardWidgetChild';
/**
 * The class name added to editable dashboard outputs.
 */
const EDITABLE_WIDGET_CLASS = 'dsh-EditableWidget';
/**
 * The class name added to markdown dashboard outputs.
 */
const MARKDOWN_OUTPUT_CLASS = 'dsh-MarkdownOutput';
/**
 * The class name added to dashboard widget drag images.
 */
const DRAG_IMAGE_CLASS = 'dsh-DragImage';
/**
 * Widget to wrap delete/move/etc functionality of widgets in a dashboard (future).
 */
class DashboardWidget extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget {
    constructor(options) {
        super();
        const { notebook, cell, cellId, notebookId, fit } = options;
        this._notebook = notebook;
        this._cell = cell || null;
        this.id = DashboardWidget.createDashboardWidgetId();
        // Makes widget focusable.
        this.node.setAttribute('tabindex', '-1');
        const _cellId = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getCellId)(cell);
        const _notebookId = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getNotebookId)(notebook);
        if (_notebookId === undefined) {
            this.node.style.background = 'red';
            if (notebookId === undefined) {
                console.warn('DashboardWidget has no notebook or notebookId');
            }
            this._notebookId = notebookId;
        }
        else if (_cellId === undefined) {
            this.node.style.background = 'yellow';
            if (cellId === undefined) {
                console.warn('DashboardWidget has no cell or cellId');
            }
            this._cellId = cellId;
        }
        else {
            if (notebookId && _notebookId !== notebookId) {
                console.warn(`DashboardWidget notebookId ('${notebookId}') and id of
                      notebook ('${_notebookId}') don't match. 
                      Using ${_notebookId}.`);
            }
            if (cellId && _cellId !== cellId) {
                console.warn(`DashboardWidget cellId ('${cellId}') and id of cell
                      ('${_cellId}') don't match. Using ${_cellId}.`);
            }
            this._cellId = _cellId;
            this._notebookId = _notebookId;
            void this._notebook.context.ready.then(() => {
                let clone;
                const cellType = cell.model.type;
                const container = document.createElement('div');
                let cloneNode;
                let nodes;
                let node;
                switch (cellType) {
                    case 'markdown':
                        cloneNode = cell.clone().node;
                        nodes = cloneNode.getElementsByClassName('jp-MarkdownOutput');
                        node = nodes[0];
                        node.style.paddingRight = '0';
                        clone = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget({ node });
                        container.classList.add(MARKDOWN_OUTPUT_CLASS);
                        break;
                    case 'code':
                        clone = cell.cloneOutputArea();
                        break;
                    default:
                        throw new Error('Cell is not a code or markdown cell.');
                }
                // Make widget invisible until it's properly loaded/sized.
                this.node.style.opacity = '0';
                container.classList.add(DASHBOARD_WIDGET_CHILD_CLASS);
                // Fake an attach in order to render LaTeX properly.
                // Note: This is not how you should use Lumino widgets.
                if (this.parent) {
                    if (this.parent.isAttached) {
                        _lumino_messaging__WEBPACK_IMPORTED_MODULE_1__.MessageLoop.sendMessage(clone, _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget.Msg.BeforeAttach);
                        container.appendChild(clone.node);
                        this.node.appendChild(container);
                        if (this.parent.isAttached) {
                            _lumino_messaging__WEBPACK_IMPORTED_MODULE_1__.MessageLoop.sendMessage(clone, _lumino_widgets__WEBPACK_IMPORTED_MODULE_0__.Widget.Msg.AfterAttach);
                        }
                    }
                }
                this._content = clone;
                const done = () => {
                    if (fit) {
                        this.fitContent();
                    }
                    // Make widget visible again.
                    this.node.style.opacity = '';
                    // Emit the ready signal.
                    this._ready.emit(undefined);
                };
                // Wait a moment then fit content. This allows all components to load
                // and for their width/height to adjust before fitting.
                setTimeout(done.bind(this), 2);
            });
        }
        const resizerTopLeft = DashboardWidget.createResizer('top-left');
        const resizerTopRight = DashboardWidget.createResizer('top-right');
        const resizerBottomLeft = DashboardWidget.createResizer('bottom-left');
        const resizerBottomRight = DashboardWidget.createResizer('bottom-right');
        this.node.appendChild(resizerTopLeft);
        this.node.appendChild(resizerTopRight);
        this.node.appendChild(resizerBottomLeft);
        this.node.appendChild(resizerBottomRight);
        this.addClass(DASHBOARD_WIDGET_CLASS);
        this.addClass(EDITABLE_WIDGET_CLASS);
    }
    /**
     * Create click listeners on attach
     */
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.node.addEventListener('click', this);
        this.node.addEventListener('contextmenu', this);
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('dblclick', this);
        this.node.addEventListener('keydown', this);
    }
    /**
     * Remove click listeners on detach
     */
    onBeforeDetach(msg) {
        super.onBeforeDetach(msg);
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('contextmenu', this);
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('dblclick', this);
        this.node.removeEventListener('keydown', this);
    }
    handleEvent(event) {
        // Just do the default behavior in present mode.
        if (this._mode === 'present') {
            return;
        }
        switch (event.type) {
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'click':
            case 'contextmenu':
                // Focuses on clicked output and blurs all others
                // Is there a more efficient way to blur other outputs?
                Array.from(document.getElementsByClassName(DASHBOARD_WIDGET_CLASS)).map(blur);
                this.node.focus();
                break;
            case 'dblclick':
                this._evtDblClick(event);
                break;
        }
    }
    /**
     * Handle the `'keydown'` event for the widget.
     */
    _evtKeyDown(event) {
        event.preventDefault();
        event.stopPropagation();
        const pos = this.pos;
        const oldPos = { ...pos };
        const bumpDistance = event.altKey ? 1 : DashboardWidget.BUMP_DISTANCE;
        switch (event.keyCode) {
            // Left arrow key
            case 37:
                pos.left -= bumpDistance;
                break;
            // Up arrow key
            case 38:
                pos.top -= bumpDistance;
                break;
            // Right arrow key
            case 39:
                pos.left += bumpDistance;
                break;
            // Down arrow key
            case 40:
                pos.top += bumpDistance;
                break;
        }
        if (pos !== oldPos) {
            this.parent.updateWidget(this, pos);
        }
    }
    /**
     * Handle the `'dblclick'` event for the widget. Currently a no-op.
     */
    _evtDblClick(event) {
        // Do nothing if it's not a left mouse press.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if any modifier keys are pressed.
        if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) {
            return;
        }
        // Stop the event propagation.
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * Handle `mousedown` events for the widget.
     */
    _evtMouseDown(event) {
        const { button, shiftKey, target } = event;
        // We only handle main or secondary button actions.
        if (!(button === 0 || button === 2) ||
            // Shift right-click gives the browser default behavior.
            (shiftKey && button === 2)) {
            return;
        }
        event.preventDefault();
        window.addEventListener('mouseup', this);
        window.addEventListener('mousemove', this);
        // this.node.style.opacity = '0.6';
        const elem = target;
        // Set mode to resize if the mousedown happened on a resizer.
        if (elem.classList.contains('dsh-Resizer')) {
            this._mouseMode = 'resize';
            if (elem.classList.contains('dsh-ResizerTopRight')) {
                this._selectedResizer = 'top-right';
            }
            else if (elem.classList.contains('dsh-ResizerTopLeft')) {
                this._selectedResizer = 'top-left';
            }
            else if (elem.classList.contains('dsh-ResizerBottomLeft')) {
                this._selectedResizer = 'bottom-left';
            }
            else {
                this._selectedResizer = 'bottom-right';
            }
        }
        else {
            this._mouseMode = 'drag';
        }
        const cell = this.cell;
        const rect = this.node.getBoundingClientRect();
        const { width, height, top, left } = this.pos;
        this._clickData = {
            pressX: event.clientX,
            pressY: event.clientY,
            cell,
            origWidth: width,
            origHeight: height,
            origLeft: left,
            origTop: top,
            target: this.node.cloneNode(true),
            widgetX: rect.left,
            widgetY: rect.top
        };
    }
    /**
     * Handle `mousemove` events for the widget.
     */
    _evtMouseMove(event) {
        switch (this._mouseMode) {
            case 'drag':
                this._dragMouseMove(event);
                break;
            case 'resize':
                this._resizeMouseMove(event);
                break;
            default:
                break;
        }
    }
    /**
     * Handle `mousemove` events when the widget mouseMode is `drag`.
     */
    _dragMouseMove(event) {
        const data = this._clickData;
        const { clientX, clientY } = event;
        if (data &&
            Private.shouldStartDrag(data.pressX, data.pressY, clientX, clientY)) {
            void this._startDrag(data.target, clientX, clientY);
        }
    }
    /**
     * Handle `mousemove` events when the widget mouseMode is `resize`.
     */
    _resizeMouseMove(event) {
        const { pressX, pressY, origWidth, origHeight, origLeft, origTop } = this._clickData;
        const deltaX = event.clientX - pressX;
        const deltaY = event.clientY - pressY;
        let { width, height, top, left } = this.pos;
        switch (this._selectedResizer) {
            case 'bottom-right':
                width = Math.max(origWidth + deltaX, DashboardWidget.MIN_WIDTH);
                height = Math.max(origHeight + deltaY, DashboardWidget.MIN_HEIGHT);
                break;
            case 'bottom-left':
                width = Math.max(origWidth - deltaX, DashboardWidget.MIN_WIDTH);
                height = Math.max(origHeight + deltaY, DashboardWidget.MIN_HEIGHT);
                left = origLeft + deltaX;
                break;
            case 'top-right':
                width = Math.max(origWidth + deltaX, DashboardWidget.MIN_WIDTH);
                height = Math.max(origHeight - deltaY, DashboardWidget.MIN_HEIGHT);
                top = origTop + deltaY;
                break;
            case 'top-left':
                width = Math.max(origWidth - deltaX, DashboardWidget.MIN_WIDTH);
                height = Math.max(origHeight - deltaY, DashboardWidget.MIN_HEIGHT);
                top = origTop + deltaY;
                left = origLeft + deltaX;
                break;
        }
        this.pos = { width, height, top, left };
        if (this.mode === 'grid-edit') {
            this.parent.layout.drawDropZone(this.pos, '#2b98f0');
        }
        if (this.mode === 'free-edit' && this._fitToContent && !event.altKey) {
            this.fitContent();
        }
    }
    /**
     * Fit widget width/height to the width/height of the underlying content.
     */
    fitContent() {
        const element = this._content.node.firstChild;
        // Pixels are added to prevent weird wrapping issues. Kind of a hack.
        this.pos = {
            width: element.clientWidth + 3,
            height: element.clientHeight + 2,
            left: 0,
            top: 0
        };
    }
    /**
     * Determines whether the widget contains the point (left, top).
     *
     * ### Notes
     * Both `left` and `top` are relative to the dashboard.
     */
    containsPoint(left, top) {
        const pos = {
            left,
            top,
            width: 0,
            height: 0
        };
        const overlap = this.overlaps(pos);
        return overlap.type !== 'none';
    }
    /**
     * Determines whether the widget overlaps an area.
     *
     * @param _pos - the position and size of the test area.
     *
     * @returns - an object containing the type of overlap and this widget.
     */
    overlaps(_pos) {
        const { left, top, width, height } = _pos;
        const pos = this.pos;
        const w = 0.5 * (width + pos.width);
        const h = 0.5 * (height + pos.height);
        const dx = left + 0.5 * width - (pos.left + 0.5 * pos.width);
        const dy = top + 0.5 * height - (pos.top + 0.5 * pos.height);
        let type = 'none';
        if (Math.abs(dx) < w && Math.abs(dy) < h) {
            if (top > pos.top + pos.height / 2) {
                type = 'up';
            }
            else {
                type = 'down';
            }
        }
        return { type, widget: this };
    }
    /**
     * Start a drag event
     */
    _startDrag(target, clientX, clientY) {
        const dragImage = target;
        dragImage.classList.add(DRAG_IMAGE_CLASS);
        this.node.style.opacity = '0';
        this.node.style.pointerEvents = 'none';
        this._drag = new _drag__WEBPACK_IMPORTED_MODULE_6__.Drag({
            mimeData: new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__.MimeData(),
            dragImage,
            proposedAction: 'move',
            supportedActions: 'copy-move',
            source: this,
            dragAdjustX: this._clickData.widgetX,
            dragAdjustY: this._clickData.widgetY
        });
        this._drag.mimeData.setData(DASHBOARD_WIDGET_MIME, this);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        return this._drag.start(clientX, clientY).then(() => {
            if (this.isDisposed) {
                return;
            }
            this.node.style.opacity = '';
            this.node.style.pointerEvents = 'auto';
            this._drag = null;
            this._clickData = null;
        });
    }
    /**
     * Handle `mouseUp` events for the widget.
     */
    _evtMouseUp(event) {
        event.stopPropagation();
        event.preventDefault();
        this.node.style.opacity = '';
        if (this._mouseMode === 'resize' && this.parent !== undefined) {
            const pos = this.pos;
            this.parent.updateWidget(this, pos);
        }
        this._mouseMode = 'none';
        this.parent.layout.clearCanvas();
        window.removeEventListener('mouseup', this);
        window.removeEventListener('mousemove', this);
    }
    /**
     * The widget's position on its dashboard.
     *
     * ### Notes
     * When setting the widget pos, fields that you don't want to modify
     * can be set as `undefined`.
     */
    get pos() {
        return {
            left: parseInt(this.node.style.left, 10),
            top: parseInt(this.node.style.top, 10),
            width: parseInt(this.node.style.width, 10),
            height: parseInt(this.node.style.height, 10)
        };
    }
    set pos(newPos) {
        const style = this.node.style;
        for (const [key, value] of Object.entries(newPos)) {
            if (value !== undefined) {
                style.setProperty(key, `${value}px`);
            }
        }
    }
    /**
     * Information sufficient to reconstruct the widget.
     */
    get info() {
        const pos = this.pos;
        return {
            pos,
            widgetId: this.id,
            cellId: this.cellId,
            notebookId: this.notebookId,
            removed: false
        };
    }
    /**
     * The id of the cell the widget is generated from.
     */
    get cellId() {
        return this._cellId || (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getCellId)(this._cell);
    }
    /**
     * The id of the notebook the widget is generated from.
     */
    get notebookId() {
        return this._notebookId || (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getNotebookId)(this._notebook);
    }
    /**
     * Whether to constrain widget dimensions to the underlying content.
     */
    get fitToContent() {
        return this._fitToContent;
    }
    set fitToContent(newState) {
        this._fitToContent = newState;
    }
    /**
     * The cell the widget is generated from.
     */
    get cell() {
        return this._cell;
    }
    /**
     * The notebook the widget is generated from.
     */
    get notebook() {
        return this._notebook;
    }
    /**
     * The index of the cell in the notebook.
     */
    get index() {
        return this._cell
            ? _lumino_algorithm__WEBPACK_IMPORTED_MODULE_3__.ArrayExt.findFirstIndex(this._notebook.content.widgets, c => c === this._cell)
            : this._index;
    }
    /**
     * The path of the notebook for the cloned output area.
     */
    get path() {
        return this._notebook.context.path;
    }
    /**
     * The widget's display mode.
     */
    get mode() {
        return this._mode;
    }
    set mode(newMode) {
        this._mode = newMode;
        if (newMode === 'present') {
            this.removeClass(EDITABLE_WIDGET_CLASS);
        }
        else {
            this.addClass(EDITABLE_WIDGET_CLASS);
        }
        if (newMode === 'grid-edit') {
            if (this.parent) {
                this.parent.updateWidget(this, this.pos);
            }
        }
    }
    /**
     * A signal emitted once the widget's content is added.
     */
    get ready() {
        return this._ready;
    }
    /**
     * Whether the widget can be moved during a resize.
     */
    get locked() {
        return this._locked;
    }
    set locked(newState) {
        this._locked = newState;
    }
    /**
     * The content of the widget.
     */
    get content() {
        return this._content;
    }
    set content(newContent) {
        this._content?.dispose();
        this._content = newContent;
    }
    _notebook;
    _notebookId;
    _index;
    _cell;
    _cellId;
    _ready = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_4__.Signal(this);
    _fitToContent = false;
    _mouseMode = 'none';
    _mode = 'grid-edit';
    _drag = null;
    _clickData = null;
    _locked = false;
    _content;
    _selectedResizer;
}
/**
 * Namespace for DashboardWidget options and constants.
 */
(function (DashboardWidget) {
    /**
     * Create a unique widget id.
     */
    function createDashboardWidgetId() {
        return `DashboardWidget-${_lumino_coreutils__WEBPACK_IMPORTED_MODULE_2__.UUID.uuid4()}`;
    }
    DashboardWidget.createDashboardWidgetId = createDashboardWidgetId;
    /**
     * Create a resizer element for a dashboard widget.
     */
    function createResizer(corner) {
        const resizer = document.createElement('div');
        resizer.classList.add('dsh-Resizer');
        switch (corner) {
            case 'top-left':
                resizer.classList.add('dsh-ResizerTopLeft');
                break;
            case 'top-right':
                resizer.classList.add('dsh-ResizerTopRight');
                break;
            case 'bottom-left':
                resizer.classList.add('dsh-ResizerBottomLeft');
                break;
            case 'bottom-right':
                resizer.classList.add('dsh-ResizerBottomRight');
                break;
            default:
                resizer.classList.add('dsh-ResizerBottomRight');
                break;
        }
        return resizer;
    }
    DashboardWidget.createResizer = createResizer;
    /**
     * Create a dashboard widget based on a WidgetInfo object.
     *
     * @param options - the options used to create the widget.
     *
     * @param notebookTracker - a notebook tracker used to locate a
     * notebook/cell for the widget given a notebook/cell id.
     *
     * @param fit - whether to fit the new widget to its content.
     *
     * @returns - a new dashboard widget.
     */
    function createWidget(options, notebookTracker, fit = false) {
        const { notebookId, cellId, pos, widgetId } = options;
        const notebook = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getNotebookById)(notebookId, notebookTracker);
        let cell;
        const _cell = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getCellById)(cellId, notebookTracker);
        if (_cell === undefined) {
            cell = undefined;
        }
        else if (_cell.model.type === 'code') {
            cell = _cell;
        }
        else if (_cell.model.type === 'markdown') {
            cell = _cell;
        }
        else {
            throw new Error('cell is not a code or markdown cell');
        }
        const widget = new DashboardWidget({
            notebookId,
            cellId,
            notebook,
            cell,
            fit
        });
        widget.pos = pos;
        widget.id = widgetId;
        return widget;
    }
    DashboardWidget.createWidget = createWidget;
    /**
     * Default width of added widgets.
     */
    DashboardWidget.DEFAULT_WIDTH = 500;
    /**
     * Default height of added widgets.
     */
    DashboardWidget.DEFAULT_HEIGHT = 500;
    /**
     * Minimum width of added widgets.
     */
    DashboardWidget.MIN_WIDTH = 10;
    /**
     * Minimum height of added widgets.
     */
    DashboardWidget.MIN_HEIGHT = 10;
    /**
     * How many pixels to adjust a widget by using the arrow keys.
     */
    DashboardWidget.BUMP_DISTANCE = 10;
})(DashboardWidget || (DashboardWidget = {}));
/**
 * A namespace for private functionality.
 */
var Private;
(function (Private) {
    const DRAG_THRESHOLD = 5;
    /**
     * Detect if a drag event should be started. This is down if the
     * mouse is moved beyond a certain distance (DRAG_THRESHOLD).
     *
     * @param prevX - X Coordinate of the mouse pointer during the mousedown event
     *
     * @param prevY - Y Coordinate of the mouse pointer during the mousedown event
     *
     * @param nextX - Current X Coordinate of the mouse pointer
     *
     * @param nextY - Current Y Coordinate of the mouse pointer
     */
    function shouldStartDrag(prevX, prevY, nextX, nextY) {
        const dx = Math.abs(nextX - prevX);
        const dy = Math.abs(nextY - prevY);
        return dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD;
    }
    Private.shouldStartDrag = shouldStartDrag;
})(Private || (Private = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DashboardWidget);


/***/ }),

/***/ "./lib/dashboard/widgetStore.js":
/*!**************************************!*\
  !*** ./lib/dashboard/widgetStore.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WIDGETS": () => (/* binding */ WIDGETS),
/* harmony export */   "WidgetStore": () => (/* binding */ WidgetStore)
/* harmony export */ });
/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./widget */ "./lib/dashboard/widget.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./lib/dashboard/utils.js");


const WIDGETS = new Map();
/**
 * A Litestore wrapper to work with DashboardWidget metadata.
 */
class WidgetStore {
    /**
     * Construct a new WidgetStore.
     *
     * @param options - the options for creating the WidgetStore.
     */
    constructor(options) {
        this._notebookTracker = options.notebookTracker;
    }
    /**
     * Start listening for changes to a dashboard and automatically
     * reflect them in the datastore.
     */
    connectDashboard(dashboard) {
        const layout = dashboard.layout;
        layout.changed.connect((layout, changes) => this._handleChanges(layout, changes));
    }
    /**
     * Stop listening for changes to a dashboard.
     */
    disconnectDashboard(dashboard) {
        const layout = dashboard.layout;
        layout.changed.disconnect((layout, changes) => this._handleChanges(layout, changes));
    }
    /**
     * Handle change signals from a connected dashboard.
     */
    _handleChanges(layout, changes) {
        layout.parent.model.dirty = true;
        for (const change of changes) {
            const { widgetId, pos, ignore } = change;
            if (ignore) {
                continue;
            }
            switch (change.type) {
                case 'add':
                    this.addWidget(change);
                    break;
                case 'move':
                    this.moveWidget(widgetId, pos);
                    break;
                case 'remove':
                    this.deleteWidget(widgetId);
                    break;
                default:
                    console.warn(`invalid IDashboardChange type '${change.type}'`);
                    break;
            }
        }
    }
    /**
     * Adds a dashboard widget to the widgetStore.
     *
     * @param info - the information to add to the widgetStore.
     */
    addWidget(info) {
        WIDGETS.set(info.widgetId, info);
    }
    /**
     * Updates the position of a widget already in the widgetStore.
     *
     * @param widget - the widget to update.
     *
     * @param pos - the new widget position.
     *
     * @returns whether the update was successful.
     *
     * ### Notes
     * The update will be unsuccesful if the widget isn't in the store or was
     * previously removed.
     */
    moveWidget(widgetId, pos) {
        const oldRecord = WIDGETS.get(widgetId);
        if (oldRecord === undefined || oldRecord.removed) {
            return false;
        }
        oldRecord.pos = pos;
        return true;
    }
    /**
     * Mark a widget as removed.
     *
     * @param widget - widget to delete.
     *
     * @returns whether the deletion was successful.
     */
    deleteWidget(widgetId) {
        const oldRecord = WIDGETS.get(widgetId);
        if (oldRecord === undefined) {
            return false;
        }
        WIDGETS.delete(widgetId);
        return true;
    }
    /**
     * Retrieves a dashboard widget's info.
     *
     * @param widgetId - id to retrieve info for.
     *
     * @returns the widget's info, or undefined if it's not in the store.
     */
    getWidget(widgetId) {
        const record = WIDGETS.get(widgetId);
        if (record === undefined) {
            return undefined;
        }
        return record;
    }
    getWidgets() {
        return WIDGETS.values();
    }
    /**
     * Gets a cell by id using the instances' notebook tracker.
     */
    getCellById(id) {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getCellById)(id, this._notebookTracker);
    }
    /**
     * Gets a notebook by id using the instances' notebook tracker.
     */
    getNotebookById(id) {
        return (0,_utils__WEBPACK_IMPORTED_MODULE_0__.getNotebookById)(id, this._notebookTracker);
    }
    /**
     * Remove all widget entries from the store.
     */
    clear() {
        WIDGETS.clear();
    }
    createWidget(options, fit) {
        return _widget__WEBPACK_IMPORTED_MODULE_1__["default"].createWidget(options, this._notebookTracker, fit);
    }
    _notebookTracker;
}
(function (WidgetStore) {
    ;
})(WidgetStore || (WidgetStore = {}));


/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook");
/* harmony import */ var _jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils");
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/cells */ "webpack/sharing/consume/default/@jupyterlab/cells");
/* harmony import */ var _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dashboard/dashboard */ "./lib/dashboard/dashboard.js");
/* harmony import */ var _dashboard_widget__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dashboard/widget */ "./lib/dashboard/widget.js");
/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager");
/* harmony import */ var _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/mainmenu */ "webpack/sharing/consume/default/@jupyterlab/mainmenu");
/* harmony import */ var _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets");
/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher");
/* harmony import */ var _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _dashboard_icons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dashboard/icons */ "./lib/dashboard/icons.js");
/* harmony import */ var _dashboard_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dashboard/model */ "./lib/dashboard/model.js");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components");
/* harmony import */ var _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dashboard/commands */ "./lib/dashboard/commands.js");
/* harmony import */ var _dashboard_widgetStore__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./dashboard/widgetStore */ "./lib/dashboard/widgetStore.js");
/* harmony import */ var _dashboard_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dashboard/utils */ "./lib/dashboard/utils.js");















const extension = {
    id: 'jupyterlab_interactive_dashboard_editor',
    autoStart: true,
    requires: [_jupyterlab_notebook__WEBPACK_IMPORTED_MODULE_0__.INotebookTracker, _jupyterlab_mainmenu__WEBPACK_IMPORTED_MODULE_4__.IMainMenu, _jupyterlab_docmanager__WEBPACK_IMPORTED_MODULE_3__.IDocumentManager, _jupyterlab_launcher__WEBPACK_IMPORTED_MODULE_6__.ILauncher],
    provides: _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.IDashboardTracker,
    activate: (app, notebookTracker, mainMenu, docManager, launcher) => {
        // Tracker for Dashboard
        const dashboardTracker = new _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.DashboardTracker({ namespace: 'dashboards' });
        // Tracker for DashboardWidgets
        const outputTracker = new _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.WidgetTracker({
            namespace: 'dashboard-outputs'
        });
        // Clipboard for copy/pasting outputs.
        const clipboard = new Set();
        // Define dashboard file type.
        const dashboardFiletype = {
            name: 'dashboard',
            displayName: 'Dashboard',
            contentType: 'file',
            extensions: ['.dashboard', '.dash'],
            fileFormat: 'text',
            icon: _dashboard_icons__WEBPACK_IMPORTED_MODULE_9__.DashboardIcons.dashboardTeal,
            iconLabel: 'Dashboard',
            mimeTypes: ['application/json']
        };
        // Add dashboard file type to the doc registry.
        app.docRegistry.addFileType(dashboardFiletype);
        addCommands(app, dashboardTracker, outputTracker, clipboard, docManager, notebookTracker);
        // Create a new model factory.
        const modelFactory = new _dashboard_model__WEBPACK_IMPORTED_MODULE_10__.DashboardModelFactory({ notebookTracker });
        // Create a new widget factory.
        const widgetFactory = new _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.DashboardDocumentFactory({
            name: 'dashboard',
            modelName: 'dashboard',
            fileTypes: ['dashboard'],
            defaultFor: ['dashboard'],
            commandRegistry: app.commands,
            outputTracker
        });
        app.docRegistry.addModelFactory(modelFactory);
        app.docRegistry.addWidgetFactory(widgetFactory);
        // Add newly created dashboards to the tracker, set their icon and label,
        // and set the default width, height, and scrollMode.
        widgetFactory.widgetCreated.connect((_sender, widget) => {
            void dashboardTracker.add(widget.content);
            widget.title.icon = dashboardFiletype.icon;
            widget.title.iconClass = dashboardFiletype.iconClass || '';
            widget.title.iconLabel = dashboardFiletype.iconLabel || '';
            const model = widget.content.model;
            // TODO: Make scrollMode changable in JL. Default 'infinite' for now.
            model.scrollMode = 'infinite';
            model.width = _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard.DEFAULT_WIDTH;
            model.height = _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard.DEFAULT_HEIGHT;
        });
        // Add commands to context menus.
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.save,
            selector: '.dsh-JupyterDashboard',
            rank: 3
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.undo,
            selector: '.dsh-JupyterDashboard',
            rank: 1
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.redo,
            selector: '.dsh-JupyterDashboard',
            rank: 2
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.cut,
            selector: '.dsh-JupyterDashboard',
            rank: 3
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.copy,
            selector: '.dsh-JupyterDashboard',
            rank: 4
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.paste,
            selector: '.dsh-JupyterDashboard',
            rank: 5
        });
        const experimentalMenu = new _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Menu({ commands: app.commands });
        experimentalMenu.title.label = 'Experimental';
        experimentalMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.saveToMetadata
        });
        experimentalMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleInfiniteScroll
        });
        experimentalMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.trimDashboard
        });
        app.contextMenu.addItem({
            type: 'submenu',
            submenu: experimentalMenu,
            selector: '.dsh-JupyterDashboard',
            rank: 6
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.deleteOutput,
            selector: '.dsh-EditableWidget',
            rank: 0
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleFitContent,
            selector: '.dsh-EditableWidget',
            rank: 1
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleWidgetMode,
            selector: '.dsh-EditableWidget',
            rank: 2
        });
        app.contextMenu.addItem({
            type: 'separator',
            selector: '.dsh-EditableWidget',
            rank: 3
        });
        app.contextMenu.addItem({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.openFromMetadata,
            selector: '.jp-Notebook',
            rank: 16
        });
        // Add commands to key bindings
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.deleteOutput,
            args: {},
            keys: ['Backspace'],
            selector: '.dsh-EditableWidget'
        });
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.undo,
            args: {},
            keys: ['Z'],
            selector: '.dsh-JupyterDashboard'
        });
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.redo,
            args: {},
            keys: ['Shift Z'],
            selector: '.dsh-JupyterDashboard'
        });
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.cut,
            args: {},
            keys: ['Accel X'],
            selector: '.dsh-JupyterDashboard'
        });
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.copy,
            args: {},
            keys: ['Accel C'],
            selector: '.dsh-JupyterDashboard'
        });
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.paste,
            args: {},
            keys: ['Accel V'],
            selector: '.dsh-JupyterDashboard'
        });
        app.commands.addKeyBinding({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleFitContent,
            args: {},
            keys: ['K'],
            selector: '.dsh-EditableWidget'
        });
        // Add commands to edit menu.
        mainMenu.fileMenu.addGroup([
            {
                command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.setDimensions
            },
            {
                command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.setTileSize
            }
        ]);
        mainMenu.fileMenu.newMenu.addGroup([
            {
                command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.createNew
            }
        ]);
        launcher.add({
            command: _dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.createNew,
            category: 'Datalayer',
            rank: 11,
        });
        return dashboardTracker;
    }
};
/**
 * Add commands to the main JupyterLab command registry.
 *
 * @param app - the JupyterLab instance.
 *
 * @param dashboardTracker - a tracker for dashboards.
 *
 * @param outputTracker - a tracker for dashboard outputs.
 *
 * @param clipboard - a set used to keep track of widgets for copy/pasting.
 *
 * @param docManager - a document manager used to create/rename files.
 *
 * @param notebookTracker - a tracker for notebooks.
 */
function addCommands(app, dashboardTracker, outputTracker, clipboard, docManager, notebookTracker) {
    const { commands } = app;
    /**
     * Whether there is an active dashboard.
     */
    function hasDashboard() {
        return dashboardTracker.currentWidget !== null;
    }
    /**
     * Whether there is a dashboard output.
     */
    function hasOutput() {
        return outputTracker.currentWidget !== null;
    }
    function inToolbar(args) {
        return args ? args.toolbar : false;
    }
    /**
     * Deletes a selected DashboardWidget.
     */
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.deleteOutput, {
        label: 'Delete Output',
        execute: args => {
            const widget = outputTracker.currentWidget;
            const dashboard = dashboardTracker.currentWidget;
            dashboard.deleteWidget(widget);
        }
    });
    /**
     * Undo the last change to a dashboard.
     */
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.undo, {
        label: args => (inToolbar(args) ? '' : 'Undo'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.undoIcon,
        execute: args => {
            dashboardTracker.currentWidget?.undo();
        },
        isEnabled: args => inToolbar(args)
    });
    /**
     * Redo the last undo to a dashboard.
     */
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.redo, {
        label: args => (inToolbar(args) ? '' : 'Redo'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.redoIcon,
        execute: args => {
            dashboardTracker.currentWidget?.redo();
        },
        isEnabled: args => inToolbar(args)
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleFitContent, {
        label: args => 'Fit To Content',
        execute: args => {
            const widget = outputTracker.currentWidget;
            widget.fitToContent = !widget.fitToContent;
            if (widget.fitToContent) {
                widget.fitContent();
            }
        },
        isVisible: args => outputTracker.currentWidget?.mode === 'free-edit',
        isToggled: args => outputTracker.currentWidget?.fitToContent || false,
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleMode, {
        icon: args => {
            const mode = dashboardTracker.currentWidget?.model.mode || 'present';
            if (mode === 'present') {
                return _dashboard_icons__WEBPACK_IMPORTED_MODULE_9__.DashboardIcons.edit;
            }
            else {
                return _dashboard_icons__WEBPACK_IMPORTED_MODULE_9__.DashboardIcons.view;
            }
        },
        label: args => {
            if (inToolbar(args)) {
                return '';
            }
            const mode = dashboardTracker.currentWidget?.model.mode || 'present';
            if (mode === 'present') {
                return 'Switch To Edit Mode';
            }
            else {
                return 'Switch To Presentation Mode';
            }
        },
        execute: args => {
            const dashboard = dashboardTracker.currentWidget;
            if (dashboard.model.mode === 'present') {
                dashboard.model.mode = 'free-edit';
            }
            else {
                dashboard.model.mode = 'present';
            }
        }
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.runOutput, {
        label: args => (inToolbar(args) ? '' : 'Run Output'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.runIcon,
        execute: args => {
            const widget = outputTracker.currentWidget;
            const sessionContext = widget.notebook.sessionContext;
            _jupyterlab_cells__WEBPACK_IMPORTED_MODULE_2__.CodeCell.execute(widget.cell, sessionContext);
        }
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.setDimensions, {
        label: 'Set Dashboard Dimensions',
        execute: async (args) => {
            const model = dashboardTracker.currentWidget?.model;
            const width = model.width ? model.width : _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard.DEFAULT_WIDTH;
            const height = model.height ? model.height : _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard.DEFAULT_HEIGHT;
            await (0,_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.showDialog)({
                title: 'Enter Dimensions',
                body: new Private.ResizeHandler(width, height),
                focusNodeSelector: 'input',
                buttons: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.cancelButton(), _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.Dialog.okButton()]
            }).then(result => {
                const value = result.value;
                let newWidth = value[0];
                let newHeight = value[1];
                if (value === null && model.width && model.height) {
                    return;
                }
                if (!newWidth) {
                    if (!model.width) {
                        newWidth = _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard.DEFAULT_WIDTH;
                    }
                    else {
                        newWidth = model.width;
                    }
                }
                if (!newHeight) {
                    if (!model.height) {
                        newHeight = _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard.DEFAULT_HEIGHT;
                    }
                    else {
                        newHeight = model.height;
                    }
                }
                model.width = newWidth;
                model.height = newHeight;
            });
        },
        isEnabled: hasDashboard
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.setTileSize, {
        label: 'Set Grid Dimensions',
        execute: async (args) => {
            const newSize = await _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.InputDialog.getNumber({
                title: 'Enter Grid Size'
            });
            if (newSize.value) {
                const layout = dashboardTracker.currentWidget?.layout;
                layout.setTileSize(newSize.value);
            }
        },
        isEnabled: hasDashboard
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.copy, {
        label: args => (inToolbar(args) ? '' : 'Copy'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.copyIcon,
        execute: args => {
            const info = outputTracker.currentWidget?.info;
            clipboard.clear();
            clipboard.add(info);
        },
        isEnabled: args => inToolbar(args) || hasOutput()
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.cut, {
        label: args => (inToolbar(args) ? '' : 'Cut'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.cutIcon,
        execute: args => {
            const widget = outputTracker.currentWidget;
            const info = widget?.info;
            const dashboard = dashboardTracker.currentWidget;
            clipboard.clear();
            clipboard.add(info);
            dashboard?.deleteWidget(widget);
        },
        isEnabled: args => inToolbar(args) || hasOutput()
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.paste, {
        label: args => (inToolbar(args) ? '' : 'Paste'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.pasteIcon,
        execute: args => {
            const id = args.dashboardId;
            let dashboard;
            if (id) {
                dashboard = dashboardTracker.find(widget => widget.id === id);
            }
            else {
                dashboard = dashboardTracker.currentWidget;
            }
            const widgetStore = dashboard.model.widgetStore;
            clipboard.forEach(info => {
                const widgetId = _dashboard_widget__WEBPACK_IMPORTED_MODULE_12__.DashboardWidget.createDashboardWidgetId();
                const pos = info.pos;
                pos.left = Math.max(pos.left - 10, 0);
                pos.top = Math.max(pos.top - 10, 0);
                const newWidget = widgetStore.createWidget({ ...info, widgetId, pos });
                dashboard.addWidget(newWidget, pos);
            });
        },
        isEnabled: args => inToolbar(args) || (hasOutput() && clipboard.size !== 0)
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.saveToMetadata, {
        label: 'Save Dashboard To Notebook Metadata',
        execute: args => {
            const dashboard = dashboardTracker.currentWidget;
            dashboard?.saveToNotebookMetadata();
        }
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.createNew, {
        label: 'Dashboard',
        icon: _dashboard_icons__WEBPACK_IMPORTED_MODULE_9__.DashboardIcons.dashboardTeal,
        execute: async (args) => {
            // A new file is created and opened separately to override the default
            // opening behavior when there's a notebook and open the dashboard in a
            // split pane instead of a tab.
            const notebook = notebookTracker.currentWidget;
            const newModel = await docManager.newUntitled({
                ext: 'dash',
                path: '/',
                type: 'file'
            });
            const path = newModel.path;
            if (notebook) {
                docManager.openOrReveal(`/${path}`, undefined, undefined, {
                    mode: 'split-left',
                    ref: notebook.id
                });
            }
            else {
                docManager.openOrReveal(`/${path}`);
            }
        }
    });
    // TODO: Make this optionally saveAs (based on filename?)
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.save, {
        label: args => (inToolbar(args) ? '' : 'Save'),
        icon: _jupyterlab_ui_components__WEBPACK_IMPORTED_MODULE_7__.saveIcon,
        execute: args => {
            const dashboard = dashboardTracker.currentWidget;
            dashboard?.context.save();
        },
        isEnabled: args => inToolbar(args) || hasDashboard()
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.openFromMetadata, {
        label: 'Open Metadata Dashboard',
        execute: args => {
            const notebook = notebookTracker.currentWidget;
            const notebookMetadata = (0,_dashboard_utils__WEBPACK_IMPORTED_MODULE_13__.getMetadata)(notebook);
            const notebookId = notebookMetadata.id;
            const cells = notebook?.content.widgets;
            const widgetStore = new _dashboard_widgetStore__WEBPACK_IMPORTED_MODULE_14__.WidgetStore({ id: 0, notebookTracker });
            for (const cell of cells) {
                const metadata = (0,_dashboard_utils__WEBPACK_IMPORTED_MODULE_13__.getMetadata)(cell);
                if (metadata !== undefined && !metadata.hidden) {
                    const widgetInfo = {
                        widgetId: _dashboard_widget__WEBPACK_IMPORTED_MODULE_12__.DashboardWidget.createDashboardWidgetId(),
                        notebookId,
                        cellId: metadata.id,
                        pos: metadata.pos
                    };
                    widgetStore.addWidget(widgetInfo);
                }
            }
            const model = new _dashboard_model__WEBPACK_IMPORTED_MODULE_10__.DashboardModel({
                widgetStore,
                notebookTracker
            });
            const dashboard = new _dashboard_dashboard__WEBPACK_IMPORTED_MODULE_8__.Dashboard({
                outputTracker,
                model
            });
            dashboard.updateLayoutFromWidgetStore();
            dashboard.model.mode = 'present';
            notebook?.context.addSibling(dashboard, { mode: 'split-left' });
        },
        isEnabled: args => {
            const notebook = notebookTracker.currentWidget;
            const metadata = (0,_dashboard_utils__WEBPACK_IMPORTED_MODULE_13__.getMetadata)(notebook);
            if (metadata !== undefined && metadata.hasDashboard !== undefined) {
                return metadata.hasDashboard;
            }
            return false;
        }
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleWidgetMode, {
        label: 'Snap to Grid',
        isToggled: args => {
            const widget = outputTracker.currentWidget;
            return widget.mode === 'grid-edit';
        },
        execute: args => {
            const widget = outputTracker.currentWidget;
            if (widget.mode === 'grid-edit') {
                widget.mode = 'free-edit';
            }
            else if (widget.mode === 'free-edit') {
                widget.mode = 'grid-edit';
            }
        }
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.toggleInfiniteScroll, {
        label: 'Infinite Scroll',
        isToggled: args => dashboardTracker.currentWidget?.model.scrollMode === 'infinite',
        execute: args => {
            const dashboard = dashboardTracker.currentWidget;
            if (dashboard.model.scrollMode === 'infinite') {
                dashboard.model.scrollMode = 'constrained';
            }
            else {
                dashboard.model.scrollMode = 'infinite';
            }
        }
    });
    commands.addCommand(_dashboard_commands__WEBPACK_IMPORTED_MODULE_11__.CommandIDs.trimDashboard, {
        label: 'Trim Dashboard',
        execute: args => {
            const dashboard = dashboardTracker.currentWidget;
            (dashboard?.layout).trimDashboard();
        }
    });
}
/**
 * A namespace for private functionality.
 */
var Private;
(function (Private) {
    /**
     * A dialog with two boxes for setting a dashboard's width and height.
     */
    class ResizeHandler extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_5__.Widget {
        constructor(oldWidth, oldHeight) {
            const node = document.createElement('div');
            const name = document.createElement('label');
            name.textContent = 'Enter New Width/Height';
            const width = document.createElement('input');
            const height = document.createElement('input');
            width.type = 'number';
            height.type = 'number';
            width.min = '0';
            width.max = '10000';
            height.min = '0';
            height.max = '10000';
            width.required = true;
            height.required = true;
            width.placeholder = `Width (${oldWidth})`;
            height.placeholder = `Height (${oldHeight})`;
            node.appendChild(name);
            node.appendChild(width);
            node.appendChild(height);
            super({ node });
        }
        getValue() {
            const inputs = this.node.getElementsByTagName('input');
            const widthInput = inputs[0];
            const heightInput = inputs[1];
            return [+widthInput.value, +heightInput.value];
        }
    }
    Private.ResizeHandler = ResizeHandler;
})(Private || (Private = {}));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (extension);


/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardGreyIcon.svg":
/*!***************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardGreyIcon.svg ***!
  \***************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n  <path fill=\"#616161\" d=\"M2 22h6v-9H2zM10 22h12v-9H10zM16 11h6V2h-6zM2 11h12V2H2z\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardOutlineWhiteIcon.svg":
/*!***********************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardOutlineWhiteIcon.svg ***!
  \***********************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n  <path fill=\"#fff\" fill-rule=\"evenodd\" d=\"M2 2h20v20H2V2zm2 2h10v6H4V4zm16 0h-4v6h4V4zm-10 8h10v8H10v-8zm-2 0H4v8h4v-8z\" clip-rule=\"evenodd\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardTealIcon.svg":
/*!***************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardTealIcon.svg ***!
  \***************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n  <path fill=\"#2DC0B7\" d=\"M2 14a1 1 0 011-1h5v8a1 1 0 01-1 1H3a1 1 0 01-1-1v-7zM10 13h11a1 1 0 011 1v7a1 1 0 01-1 1H11a1 1 0 01-1-1v-8zM16 3a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1h-5V3zM2 3a1 1 0 011-1h10a1 1 0 011 1v8H3a1 1 0 01-1-1V3z\" class=\"jp-icon-selectable\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/DashboardWhiteIcon.svg":
/*!****************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DashboardWhiteIcon.svg ***!
  \****************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n  <path fill=\"#fff\" d=\"M2 14a1 1 0 011-1h5v8a1 1 0 01-1 1H3a1 1 0 01-1-1v-7zM10 13h11a1 1 0 011 1v7a1 1 0 01-1 1H11a1 1 0 01-1-1v-8zM16 3a1 1 0 011-1h4a1 1 0 011 1v7a1 1 0 01-1 1h-5V3zM2 3a1 1 0 011-1h10a1 1 0 011 1v8H3a1 1 0 01-1-1V3z\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/DragIndicatorIcon.svg":
/*!***************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DragIndicatorIcon.svg ***!
  \***************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n  <circle cx=\"18\" cy=\"18\" r=\"2\" fill=\"#757575\"/>\n  <circle cx=\"12\" cy=\"18\" r=\"2\" fill=\"#757575\"/>\n  <circle cx=\"6\" cy=\"18\" r=\"2\" fill=\"#757575\"/>\n  <circle cx=\"18\" cy=\"12\" r=\"2\" fill=\"#757575\"/>\n  <circle cx=\"12\" cy=\"12\" r=\"2\" fill=\"#757575\"/>\n  <circle cx=\"18\" cy=\"6\" r=\"2\" fill=\"#757575\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/DragIndicatorLinesIcon.svg":
/*!********************************************************************!*\
  !*** ../../../../icons/react/data1/esm/DragIndicatorLinesIcon.svg ***!
  \********************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 20 20\" aria-hidden=\"true\">\n  <path fill=\"#757575\" stroke=\"#fff\" stroke-width=\".5\" d=\"M17.39 5.646l1.381 1.381L7.028 18.771 5.647 17.39zM17.811 14.991l1.381 1.381-2.804 2.804-1.381-1.38zM17.48 10.438l1.381 1.38-7.049 7.05-1.38-1.381z\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/EditIcon.svg":
/*!******************************************************!*\
  !*** ../../../../icons/react/data1/esm/EditIcon.svg ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 16 16\" aria-hidden=\"true\">\n  <path fill=\"#757575\" d=\"M0 12.667V16h3.333l9.83-9.83L9.83 2.837 0 12.667zm15.74-9.074a.885.885 0 000-1.253L13.66.26a.885.885 0 00-1.253 0l-1.626 1.626 3.333 3.333 1.626-1.626z\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/FullscreenIcon.svg":
/*!************************************************************!*\
  !*** ../../../../icons/react/data1/esm/FullscreenIcon.svg ***!
  \************************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 18 18\" aria-hidden=\"true\">\n  <path fill=\"#757575\" d=\"M3.643 11.143H1.5V16.5h5.357v-2.143H3.643v-3.214zM1.5 6.857h2.143V3.643h3.214V1.5H1.5v5.357zm12.857 7.5h-3.214V16.5H16.5v-5.357h-2.143v3.214zM11.143 1.5v2.143h3.214v3.214H16.5V1.5h-5.357z\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/RedoIcon.svg":
/*!******************************************************!*\
  !*** ../../../../icons/react/data1/esm/RedoIcon.svg ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 18 18\" aria-hidden=\"true\">\n  <path fill=\"#616161\" d=\"M8.977 6c1.987 0 3.787.742 5.175 1.95l2.7-2.7V12h-6.75l2.715-2.715a5.965 5.965 0 00-3.84-1.41A6.009 6.009 0 003.277 12l-1.778-.585C2.542 8.273 5.49 6 8.977 6z\"/>\n</svg>\n";

/***/ }),

/***/ "../../../../icons/react/data1/esm/ViewIcon.svg":
/*!******************************************************!*\
  !*** ../../../../icons/react/data1/esm/ViewIcon.svg ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 18 12\" aria-hidden=\"true\">\n  <path fill=\"#757575\" d=\"M9 .375C5.25.375 2.047 2.708.75 6c1.297 3.293 4.5 5.625 8.25 5.625S15.953 9.293 17.25 6C15.953 2.708 12.75.375 9 .375zM9 9.75C6.93 9.75 5.25 8.07 5.25 6c0-2.07 1.68-3.75 3.75-3.75 2.07 0 3.75 1.68 3.75 3.75 0 2.07-1.68 3.75-3.75 3.75zm0-6A2.247 2.247 0 006.75 6 2.247 2.247 0 009 8.25 2.247 2.247 0 0011.25 6 2.247 2.247 0 009 3.75z\"/>\n</svg>\n";

/***/ })

}]);
//# sourceMappingURL=lib_index_js-webpack_sharing_consume_default_react-dom-webpack_sharing_consume_default_react.66001d1350632a94295d.js.map