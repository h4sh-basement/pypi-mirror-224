{"version":3,"file":"lib_index_js.be73e084bd6e8366f0c0.js","mappings":";;;;;;;;;;;;;AAAA,iEAAe,svBAAsvB;;;;;;;;;;;;;;;;;;;;;;ACAztB;AACE;AAC9C;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,0DAAO;AAC9B,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC,QAAQ;AAC3C;AACA,yBAAyB,uDAAe,WAAW,uDAAe;AAClE;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpGA;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACT+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,kEAAgB;AACrC,uBAAuB,yDAAM;AAC7B;AACA;AACA;AACA,yBAAyB,kEAAgB;AACzC;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAgB;AAClC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACb;AACiB;AACK;AACP;AACJ;AACkB;AACd;AACb;AAC3C;AACA;AACqD;AACvB;AACJ;AAC1B;AACoD;AAC8C;AAC3D;AACvC,YAAY,4CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,kCAAkC,qDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAM;AACjC;AACA;AACA;AACA;AACA,sBAAsB,wDAAM;AAC5B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,+BAA+B,uDAAQ,gBAAgB,0DAAO;AAC9D;AACA,2CAA2C,yDAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAQ,CAAC,0DAAO;AAC/C;AACA;AACA,uBAAuB,wDAAW;AAClC;AACA;AACA;AACA,+BAA+B,0DAAiB,CAAC,MAAM,wDAAe,CAAC;AACvE;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,0DAAiB;AACxC;AACA,mCAAmC,yDAAgB;AACnD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAQ,gBAAgB,0DAAO;AAChE;AACA,2CAA2C,yDAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,sDAAa;AAClD;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAa;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAa;AAC9C;AACA;AACA,sBAAsB,sDAAa;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAa;AAClC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB,sDAAa;AAClC;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA,qBAAqB,sDAAa;AAClC;AACA;AACA;AACA,qBAAqB,sDAAa;AAClC,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,8BAA8B,gEAAU;AACxC;AACA;AACA;AACA,gCAAgC,wDAAM;AACtC;AACA,iCAAiC;AACjC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,2BAA2B,sDAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA,gDAAgD,sDAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAa;AACjC;AACA;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA,kDAAkD,sDAAa;AAC/D;AACA,oBAAoB,sDAAa;AACjC;AACA;AACA;AACA;AACA,2DAA2D,EAAE;AAC7D;AACA,kCAAkC,sDAAa;AAC/C;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD,iCAAiC,uDAAQ,gBAAgB,0DAAO;AAChE;AACA,2CAA2C,yDAAgB;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAU;AAC1C;AACA;AACA;AACA;AACA,cAAc,qDAAU,sBAAsB,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAU;AACxB;AACA;AACA;AACA;AACA,uBAAuB,qDAAqD;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAmB;AAC7C,IAAI,2DAAmB;AACvB;AACA;AACA,QAAQ,2DAAmB,QAAQ,2EAA2E,kBAAkB,gDAAgD;AAChL;AACA;AACA,IAAI,2DAAmB;AACvB,IAAI,2DAAmB;AACvB,IAAI,2DAAmB,UAAU;AACjC;AACA;AACA;AACA;AACA,WAAW;AACX,IAAI,2DAAmB;AACvB;AACA;AACA,2BAA2B,+DAAa;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,kEAAkB;AACrC;AACA,SAAS;AACT;AACA;AACA,4BAA4B,8DAAO;AACnC;AACA,YAAY,8DAAa;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAgB,EAAE,kEAAgB,EAAE,iEAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAU;AACnD;AACA;AACA;AACA,4BAA4B,wDAAM;AAClC;AACA,6BAA6B;AAC7B,4BAA4B,wDAAM,gBAAgB,yCAAyC;AAC3F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC","sources":["webpack://@deshaw/jupyterlab-pyflyby/./style/tidy-import.svg","webpack://@deshaw/jupyterlab-pyflyby/./lib/cellUtils.js","webpack://@deshaw/jupyterlab-pyflyby/./lib/constants.js","webpack://@deshaw/jupyterlab-pyflyby/./lib/handler.js","webpack://@deshaw/jupyterlab-pyflyby/./lib/index.js"],"sourcesContent":["export default \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 512 512\\\"><!-- Font Awesome Pro 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) --><path d=\\\"M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z\\\"/></svg>\";","import { toArray } from '@lumino/algorithm';\nimport { PYFLYBY_END_MSG } from './constants';\n// FIXME: There's got to be a better Typescript solution\n// for distinguishing between members of a union type at runtime.\nexport const normalizeMultilineString = (source) => {\n    // Multilinestring can be an array of strings or string\n    return typeof source === 'string' ? source.split('\\n') : source;\n};\n/**\n * Very hacky code snippets to check if a line could be a code statement.\n * This could go wrong in a lot of ways and will just work in the\n * most common use cases.\n *\n * Expected to return true for import and code blocks\n */\nexport const couldBeCode = (line) => {\n    return (!(line.startsWith('#') ||\n        line.startsWith('\"\"\"') ||\n        line.trim() === '' ||\n        line.match(/^\\s.*$/)) || line.startsWith('%'));\n};\nexport const couldBeImportStatement = (line) => {\n    return (couldBeCode(line) &&\n        (line.includes('__future__') ||\n            line.split(' ').indexOf('import') !== -1 ||\n            line.includes('import_all_names')));\n};\n/**\n * It is safe to insert import only if current line is empty or doesn't start with a whitespace\n * */\nexport const safeToinsertImport = (line) => {\n    return line.trim() === '' || !line.match(/^\\s.*$/);\n};\n/**\n * Takes in a list of cell models and returns\n * the first *code* cell that\n *\n * - doesn't start with a line or cell magic\n *   (If it is line magic, should we inspect the following block of code?)\n * - isn't all import blocks and comments.\n *\n * @param cellModels - an array of cell models\n */\nexport const findCell = (cellModels) => {\n    const cellsArray = toArray(cellModels);\n    for (let i = 0; i < cellsArray.length; i++) {\n        const cellModel = cellsArray[i];\n        if (cellModel.type === 'code') {\n            const lines = normalizeMultilineString(cellModel.toJSON().source);\n            // FIXME: Deal with line magics better.\n            if (lines.length > 0 &&\n                !lines[0].startsWith('%') &&\n                !lines[0].startsWith('\"\"\"')) {\n                for (let j = 0; j < lines.length; j++) {\n                    if (couldBeCode(lines[j])) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n};\n/**\n * Find the last import in a cell and return the position after that.\n *\n * If no imports exist, but code does, return 0.\n *\n * Else, it is likely an empty cell or a comment cell. Return -1.\n *\n * If we decide to reformat on each import, we can change this to\n * insert at the end of any code cell and just\n *\n * @param cell - a cell model\n */\nexport const findLinePos = (cell) => {\n    const lines = normalizeMultilineString(cell.toJSON().source);\n    for (let i = lines.length - 1; i >= 0; i--) {\n        // If PYFLYBY_END_MSG is found, add new import statement above it\n        if (lines[i] === PYFLYBY_END_MSG.substr(0, PYFLYBY_END_MSG.length - 1)) {\n            let pos = 0;\n            for (let j = 0; j < i - 1; j++) {\n                pos += lines[j].length + 1;\n            }\n            return pos;\n        }\n    }\n    for (let i = lines.length - 1; i >= 0; i--) {\n        if (couldBeImportStatement(lines[i]) &&\n            (i === lines.length - 1 || safeToinsertImport(lines[i + 1]))) {\n            let pos = 0;\n            for (let j = 0; j <= i; j++) {\n                pos += lines[j].length + 1;\n            }\n            return pos;\n        }\n    }\n    // Cell contains only comments or magics, so return -1.\n    // These imports will be moved to next cell\n    return -1;\n};\n","/** Constants */\nexport const PYFLYBY_CELL_TAG = 'pyflyby-cell';\nexport const PYFLYBY_START_MSG = '# THIS CELL WAS AUTO-GENERATED BY PYFLYBY\\n';\nexport const PYFLYBY_END_MSG = '# END AUTO-GENERATED BLOCK\\n';\nexport const PYFLYBY_COMMS = {\n    MISSING_IMPORTS: 'pyflyby.missing_imports',\n    FORMAT_IMPORTS: 'pyflyby.format_imports',\n    INIT: 'pyflyby.init_comms',\n    TIDY_IMPORTS: 'pyflyby.tidy_imports'\n};\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'pyflyby', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","/**\n * Basic workflow -\n * 1. Connects to comms created by pyflyby\n * 2. Recieves imports added by pyflyby via PYFLYBY_COMMS.MISSING_IMPORTS\n * 3. Sends import statements recived in previous step to kernel for formatting using tidy_imports\n * 4. Recieves formatted imports via PYFLYBY_COMMS.FORMAT_IMPORTS which are added at suitable location in notebook\n *\n * Selecting cell where imports are added -\n * 1. First cell with 'pyflyby-cell' tag, if not  present then next step.\n * 2. First code cell which does not contain magic command\n * 3. If selected cell doesn't contain any import statement, add a new cell above the code cell.\n *\n * Selecting insert location inside the cell -\n * 1. If PYFLYBY_END_MSG is present, import is added above it.\n * 2. Added import after last import statement in code cell. Identifying import statement is\n *    is done by simple heuristics. This step can be shifted to pyflyby where python parser can be used to\n *    determine it accurately.\n */\n// Lumino imports\nimport { toArray, ArrayExt } from '@lumino/algorithm';\nimport { Widget } from '@lumino/widgets';\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { ICommandPalette, ToolbarButton } from '@jupyterlab/apputils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Signal } from '@lumino/signaling';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport tidyImportSVG from '../style/tidy-import.svg';\nimport { debug } from 'debug';\nimport React from 'react';\n// relative imports\nimport { findCell, findLinePos } from './cellUtils';\nimport { PYFLYBY_CELL_TAG, PYFLYBY_START_MSG, PYFLYBY_END_MSG, PYFLYBY_COMMS } from './constants';\nimport { requestAPI } from './handler';\nconst log = debug('PYFLYBY:');\nclass CommLock {\n    constructor(_lockTimeout, sessionContext) {\n        this._lockTimeout = _lockTimeout;\n        this._activeTimeout = null;\n        this.requestedLockCount = 0;\n        this.clearedLockCount = 0;\n        this._releaseLock = {};\n        this.promise = { 0: Promise.resolve() };\n        this._timeoutSignal = new Signal(this);\n        this._sessionContext = sessionContext;\n        this._sessionContext.statusChanged.connect(this.kernelStateRecorder, this);\n        this._timeoutSignal.connect(this.timeoutExpireHandler, this);\n    }\n    kernelStateRecorder(sender, args) {\n        this._recentKernelState = args;\n    }\n    _clearTimeout() {\n        window.clearTimeout(this._activeTimeout);\n        this._activeTimeout = null;\n    }\n    /*\n      If the kernel was busy the last time, we assume it was busy executing\n      code and we restart the timeout.\n    */\n    timeoutExpireHandler(sender, id) {\n        this._clearTimeout();\n        if (this._recentKernelState === 'busy') {\n            console.debug('Extending Timeout For: ', id);\n            this.createTimeout(id);\n        }\n        else {\n            this.release(id);\n        }\n    }\n    async acquire() {\n        const lastLockPromise = this.promise[this.requestedLockCount];\n        this.requestedLockCount++;\n        const lockId = this.requestedLockCount;\n        this.promise[lockId] = new Promise(resolve => {\n            this._releaseLock[lockId] = resolve;\n        });\n        await lastLockPromise;\n        return new Promise((res, rej) => res(lockId));\n    }\n    release(lockId) {\n        var _a, _b;\n        this.clearedLockCount = lockId;\n        (_b = (_a = this._releaseLock)[lockId]) === null || _b === void 0 ? void 0 : _b.call(_a);\n        delete this._releaseLock[lockId];\n        this._clearTimeout();\n        if (this.clearedLockCount < this.requestedLockCount) {\n            this.createTimeout(lockId + 1);\n        }\n    }\n    createTimeout(id) {\n        this._activeTimeout = setTimeout(() => {\n            this._timeoutSignal.emit(id);\n        }, this._lockTimeout);\n    }\n}\n// We'd like to show the notification only once per session, not for each notebook\nlet _userWasNotified = false;\n/**\n * An extension that adds pyflyby integration to a single notebook widget\n */\nclass PyflyByWidget extends Widget {\n    constructor(context, panel, settingRegistry) {\n        super();\n        this._context = null;\n        this._sessionContext = null;\n        this._settings = null;\n        this._comms = {};\n        // get a reference to the settings registry\n        settingRegistry.load('@deshaw/jupyterlab-pyflyby:plugin').then((settings) => {\n            this._settings = settings;\n            const enabled = settings.get('enabled').user || settings.get('enabled').composite;\n            if (enabled) {\n                this._sessionContext.kernelChanged.connect(this._handleKernelChange, this);\n                this._sessionContext.statusChanged.connect(this._handleKernelStatusChange, this);\n            }\n            const _lockTimeout = 1000 *\n                (settings.get('lockTimeout').user ||\n                    settings.get('lockTimeout').composite);\n            this._lock = new CommLock(_lockTimeout, this._sessionContext);\n        }, (err) => {\n            log('PYFLYBY extension has been disabled');\n        });\n        this._context = context;\n        this._sessionContext = context.sessionContext;\n    }\n    async _launchDialog(imports) {\n        /**\n         * Since we are making the first import, create a new dialog\n         */\n        const dialog = new Dialog({\n            title: 'PYFLYBY',\n            body: `PYFLYBY will be adding imports to the first code cell in the notebook.\n            To disable the PYFLYBY extension or to disable this notification in future, go\n            to Settings -> Advanced Settings Editor and choose PYFLYBY preferences tab`,\n            buttons: [Dialog.okButton()]\n        });\n        try {\n            await dialog.launch();\n            return imports;\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    /**\n     * All the logic related to finding the right cell\n     */\n    _findAndSetImportCoordinates() {\n        const { model } = this._context;\n        let pyflybyCellIndex = ArrayExt.findFirstIndex(toArray(model.cells), (cell, index) => {\n            const tags = cell.metadata.get('tags');\n            return !!(tags && tags.indexOf(PYFLYBY_CELL_TAG) !== -1);\n        });\n        /**\n         * Since the cell doesn't exist, we make one or, if the first\n         * code cell contains an import block, put it below that.\n         */\n        if (pyflybyCellIndex === -1) {\n            pyflybyCellIndex = findCell(toArray(model.cells));\n        }\n        let cell = model.cells.get(pyflybyCellIndex);\n        let position = findLinePos(model.cells.get(pyflybyCellIndex));\n        if (position === -1) {\n            cell = this._context.model.contentFactory.createCodeCell({\n                cell: {\n                    source: `${PYFLYBY_START_MSG}\\n\\n${PYFLYBY_END_MSG}`,\n                    cell_type: 'code',\n                    metadata: {}\n                }\n            });\n            this._context.model.cells.insert(pyflybyCellIndex, cell);\n            position = PYFLYBY_START_MSG.length + 1;\n        }\n        cell.metadata.set('tags', [PYFLYBY_CELL_TAG]);\n        return { cellIndex: pyflybyCellIndex, position };\n    }\n    /**\n     * Adds the import block to the appropriate cell at the appropriate\n     * location.\n     *\n     * @param importBlock - the import statement or block of import statements\n     */\n    _insertImport(imports) {\n        let p = null;\n        if (!_userWasNotified && !this._settings.get('disableNotification').user) {\n            p = this._launchDialog(imports);\n            _userWasNotified = true;\n        }\n        else {\n            p = Promise.resolve(imports);\n        }\n        // creates the cell for imports\n        this._findAndSetImportCoordinates();\n        return p;\n    }\n    _sendFormatCodeMsg(imports, lockId) {\n        const pyflybyCellIndex = ArrayExt.findFirstIndex(toArray(this._context.model.cells), (cell, index) => {\n            const tags = cell.metadata.get('tags');\n            return !!(tags && tags.indexOf(PYFLYBY_CELL_TAG) !== -1);\n        });\n        if (pyflybyCellIndex !== -1) {\n            const cellSource = this._context.model.cells\n                .get(pyflybyCellIndex)\n                .toJSON().source;\n            const comm = this._comms[PYFLYBY_COMMS.FORMAT_IMPORTS];\n            if (comm && !comm.isDisposed) {\n                comm.send({\n                    msg_id: lockId,\n                    input_code: cellSource,\n                    imports: imports,\n                    type: PYFLYBY_COMMS.FORMAT_IMPORTS\n                });\n            }\n        }\n    }\n    async sendTidyImportRequest() {\n        const cellArray = this._getCellArray();\n        const comm = this._comms[PYFLYBY_COMMS.TIDY_IMPORTS];\n        if (comm && !comm.isDisposed) {\n            comm.send({\n                type: PYFLYBY_COMMS.TIDY_IMPORTS,\n                cellArray: cellArray,\n                checksum: this._getHashOfCodeInNotebook()\n            });\n        }\n    }\n    _getCellArray() {\n        const cells = this._context.model.cells;\n        const cellArray = [];\n        for (let i = 0; i < cells.length; ++i) {\n            cellArray.push({\n                text: cells.get(i).value.text,\n                type: cells.get(i).type\n            });\n        }\n        return cellArray;\n    }\n    restoreNotebookAfterTidyImports(cellArray, imports) {\n        const { cellIndex } = this._findAndSetImportCoordinates();\n        const cells = this._context.model.cells;\n        for (let i = 0; i < cellArray.length; ++i) {\n            const cell = cells.get(i);\n            cell.value.remove(0, cell.value.text.length);\n            cell.value.insert(0, cellArray[i].text.trim());\n        }\n        const joined_imports = imports.join('\\n').trim();\n        if (cells.get(0).value.text.length === 0) {\n            cells.get(0).value.insert(0, joined_imports);\n        }\n        else {\n            const cell = this._context.model.contentFactory.createCodeCell({\n                cell: {\n                    source: joined_imports,\n                    cell_type: 'code',\n                    metadata: {\n                        trusted: true\n                    }\n                }\n            });\n            cells.insert(cellIndex, cell);\n        }\n    }\n    _fastStringHash(str) {\n        let hash = 0;\n        for (let i = 0, len = str.length; i < len; i++) {\n            const chr = str.charCodeAt(i);\n            hash = (hash << 5) - hash + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n    _getHashOfCodeInNotebook() {\n        const cellArray = this._getCellArray();\n        let joinedText = '';\n        for (let i = 0; i < cellArray.length; ++i) {\n            joinedText = joinedText + cellArray[i].text;\n        }\n        return this._fastStringHash(joinedText);\n    }\n    _getCommMsgHandler() {\n        return async (msg) => {\n            const msgContent = msg.content.data;\n            switch (msgContent.type) {\n                case PYFLYBY_COMMS.MISSING_IMPORTS: {\n                    const itd = msgContent['missing_imports'];\n                    this._insertImport(itd).then(async (imports) => {\n                        // Acquire new lock but wait for previous lock to expire\n                        const currentLockId = await this._lock.acquire();\n                        this._sendFormatCodeMsg(imports, currentLockId);\n                    });\n                    break;\n                }\n                case PYFLYBY_COMMS.FORMAT_IMPORTS: {\n                    this._formatImports(msgContent);\n                    const { msg_id: lockId } = msgContent;\n                    this._lock.release(lockId);\n                    break;\n                }\n                case PYFLYBY_COMMS.INIT: {\n                    this._initializeComms().catch(console.error);\n                    break;\n                }\n                case PYFLYBY_COMMS.TIDY_IMPORTS: {\n                    const { cells, imports, checksum } = msgContent;\n                    if (checksum === this._getHashOfCodeInNotebook()) {\n                        this.restoreNotebookAfterTidyImports(cells, imports);\n                    }\n                    else {\n                        await showDialog({\n                            title: 'TidyImports Interrupted',\n                            body: 'TidyImports could not be run because code in the notebook has been changed',\n                            buttons: [\n                                Dialog.okButton({\n                                    label: 'Ok'\n                                })\n                            ],\n                            defaultButton: 0\n                        });\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        };\n    }\n    async _initializeComms() {\n        if (!this._sessionContext.session) {\n            return;\n        }\n        const { kernel } = this._sessionContext.session;\n        if (!kernel) {\n            return;\n        }\n        // Open the comm\n        const targetName = PYFLYBY_COMMS.MISSING_IMPORTS;\n        const comm = kernel.createComm(targetName);\n        comm.onMsg = this._getCommMsgHandler();\n        try {\n            comm.open();\n        }\n        catch (e) {\n            console.error(`Unable to open PYFLYBY comm - ${e}`);\n        }\n        const formatMsgComm = kernel.createComm(PYFLYBY_COMMS.FORMAT_IMPORTS);\n        formatMsgComm.onMsg = this._getCommMsgHandler();\n        formatMsgComm.onClose = (msg) => {\n            const commId = msg.content.comm_id;\n            delete this._comms[commId];\n        };\n        this._comms[PYFLYBY_COMMS.FORMAT_IMPORTS] = formatMsgComm;\n        try {\n            formatMsgComm.open();\n        }\n        catch (e) {\n            console.error(`Unable to open PYFLYBY comm - ${e}`);\n        }\n        const tidyImportsComm = kernel.createComm(PYFLYBY_COMMS.TIDY_IMPORTS);\n        tidyImportsComm.onMsg = this._getCommMsgHandler();\n        this._comms[PYFLYBY_COMMS.TIDY_IMPORTS] = tidyImportsComm;\n        try {\n            tidyImportsComm.open();\n        }\n        catch (e) {\n            console.error(`Unable to open PYFLYBY comm - ${e}`);\n        }\n        kernel.registerCommTarget(PYFLYBY_COMMS.INIT, (comm, msg) => {\n            comm.onMsg = this._getCommMsgHandler();\n        });\n        return Promise.resolve();\n    }\n    _formatImports(msgData) {\n        const { formatted_code: formattedCode } = msgData;\n        const pyflybyCellIndex = ArrayExt.findFirstIndex(toArray(this._context.model.cells), (cell, index) => {\n            const tags = cell.metadata.get('tags');\n            return !!(tags && tags.indexOf(PYFLYBY_CELL_TAG) !== -1);\n        });\n        if (pyflybyCellIndex !== -1) {\n            const cell = this._context.model.cells.get(pyflybyCellIndex);\n            cell.value.remove(0, cell.value.text.length);\n            cell.value.insert(0, formattedCode);\n        }\n    }\n    async _handleKernelChange(sender, kernelChangedArgs) {\n        return await this._initializeComms();\n    }\n    _handleKernelStatusChange(sender, args) {\n        if (args === 'restarting') {\n            return this._initializeComms();\n        }\n        return null;\n    }\n}\n/**\n * An extension that adds pyflyby integration to a notebook widget\n */\nclass PyflyByWidgetExtension {\n    constructor(settingRegistry) {\n        this._settingRegistry = null;\n        // get a reference to the settings registry\n        // This is shared between all notebooks. I.e. not possible to\n        // have different pyflyby settings for different notebooks\n        this._settingRegistry = settingRegistry;\n        this._loadSettings().catch(console.error);\n    }\n    async _loadSettings() {\n        try {\n            await this._settingRegistry.load('@deshaw/jupyterlab-pyflyby:plugin');\n            log('Successfully loaded PYFLYBY extension settings');\n        }\n        catch (e) {\n            console.error('Settings could not be loaded');\n        }\n    }\n    createNew(panel, context) {\n        pyflybyWidget = new PyflyByWidget(context, panel, this._settingRegistry);\n        return pyflybyWidget;\n    }\n}\nasync function isPyflybyInstalled() {\n    const pyflybyStatus = await requestAPI('pyflyby-status');\n    return pyflybyStatus.status;\n}\nasync function installPyflyby() {\n    try {\n        await requestAPI('install-pyflyby', { method: 'POST' });\n    }\n    catch (err) {\n        const errMsg = await err.json();\n        console.error(errMsg.result);\n    }\n}\nasync function disableJupyterlabPyflyby(registry) {\n    try {\n        await requestAPI('disable-pyflyby', {\n            method: 'POST',\n            mode: 'cors',\n            cache: 'no-cache',\n            credentials: 'include',\n            headers: { 'Content-type': 'application/x-www-form-urlencoded' },\n            body: new URLSearchParams('installDialogDisplayed=true')\n        });\n    }\n    catch (err) {\n        const errMsg = await err.json();\n        console.error(errMsg.result);\n    }\n    await registry.reload('@deshaw/jupyterlab-pyflyby:plugin');\n}\nconst installationBody = (React.createElement(\"div\", null,\n    React.createElement(\"p\", null,\n        \"To use @deshaw/jupyterlab-pyflyby,\",\n        ' ',\n        React.createElement(\"a\", { href: \"https://github.com/deshaw/pyflyby/blob/master/README.rst\", style: { color: '#0000EE' }, target: \"_blank\", rel: \"noopener noreferrer\" }, \"pyflyby\"),\n        ' ',\n        \"ipython extension needs to be installed.\"),\n    React.createElement(\"br\", null),\n    React.createElement(\"p\", null, \"Clicking on \\\"Install\\\" will run following command\"),\n    React.createElement(\"div\", { style: {\n            font: 'monospace',\n            color: '#ffffff',\n            backgroundColor: '#000000',\n            marginTop: '5px'\n        } }, \"$ py pyflyby.install_in_ipython_config_file\"),\n    React.createElement(\"br\", null)));\nclass TidyImportButtonExtension {\n    createNew(widget, context) {\n        const button = new ToolbarButton({\n            className: 'tidy-import-button',\n            tooltip: 'Run tidy-imports on this notebook',\n            icon: TidyImportsIcon,\n            onClick: () => pyflybyWidget.sendTidyImportRequest()\n        });\n        widget.toolbar.insertItem(10, 'tidy-imports', button);\n        return new DisposableDelegate(() => {\n            button.dispose();\n        });\n    }\n}\nconst TidyImportsIcon = new LabIcon({\n    name: 'TidyImports',\n    svgstr: tidyImportSVG\n});\nlet pyflybyWidget = null;\nconst djsTidyImportsCommand = 'djs:run-tidy-imports';\nconst extension = {\n    id: '@deshaw/jupyterlab-pyflyby:plugin',\n    autoStart: true,\n    requires: [ISettingRegistry, INotebookTracker, ICommandPalette],\n    activate: async function (app, registry, tracker, palette) {\n        console.log('JupyterLab extension @deshaw/jupyterlab-pyflyby is activated!');\n        app.commands.addCommand(djsTidyImportsCommand, {\n            execute: () => pyflybyWidget.sendTidyImportRequest(),\n            icon: TidyImportsIcon,\n            label: 'Run tidy-imports on Notebook'\n        });\n        palette.addItem({\n            command: djsTidyImportsCommand,\n            category: 'Notebook'\n        });\n        const settings = await registry.load('@deshaw/jupyterlab-pyflyby:plugin');\n        const enabled = settings.get('enabled').user || settings.get('enabled').composite;\n        const dialogDisplayedEarlier = settings.get('installDialogDisplayed').user;\n        if (enabled) {\n            const response = await isPyflybyInstalled();\n            if (response !== 'loaded') {\n                if (dialogDisplayedEarlier) {\n                    // Dialog to install pyflyby ipython extensions was displayed earlier,\n                    // install it since user is trying to use pyflyby by manually enabling\n                    // jupyterlab-pyflyby\n                    await installPyflyby();\n                }\n                else {\n                    const result = await showDialog({\n                        title: 'Installation required',\n                        body: installationBody,\n                        buttons: [\n                            Dialog.okButton({\n                                label: 'Install'\n                            }),\n                            Dialog.cancelButton({ label: 'Cancel', displayType: 'default' })\n                        ],\n                        defaultButton: 0\n                    });\n                    result.button.accept\n                        ? await installPyflyby()\n                        : await disableJupyterlabPyflyby(registry);\n                }\n            }\n        }\n        app.docRegistry.addWidgetExtension('Notebook', new PyflyByWidgetExtension(registry));\n        app.docRegistry.addWidgetExtension('Notebook', new TidyImportButtonExtension());\n    }\n};\nexport default extension;\n"],"names":[],"sourceRoot":""}