# Copyright 2023 Marc Lehmann

# This file is part of tablecache.
#
# tablecache is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# tablecache is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License
# along with tablecache. If not, see <https://www.gnu.org/licenses/>.

import asyncio

import asyncpg
from hamcrest import *
import pytest

import tablecache as tc


@pytest.fixture(scope='session')
def postgres_host():
    import socket
    try:
        return socket.gethostbyname('postgres')
    except socket.gaierror:
        return 'localhost'


@pytest.fixture(scope='session')
def postgres_dsn(postgres_host):
    return f'postgres://postgres:@{postgres_host}:5432/postgres'


@pytest.fixture(scope='session')
async def wait_for_postgres(postgres_dsn):
    start_time = asyncio.get_running_loop().time()
    while True:
        try:
            conn = await asyncpg.connect(dsn=postgres_dsn)
            await conn.close()
            return
        except Exception as e:
            if asyncio.get_running_loop().time() > start_time + 60:
                raise Exception('Testing Postgres isn\'t coming up.') from e
            await asyncio.sleep(0.1)


@pytest.fixture(scope='session')
async def pool(wait_for_postgres, postgres_dsn):
    async with asyncpg.create_pool(dsn=postgres_dsn) as pool:
        yield pool


@pytest.fixture(autouse=True)
async def setup_db(pool):
    await pool.execute(
        '''
        DROP SCHEMA public CASCADE;
        CREATE SCHEMA public;
        CREATE TABLE users (
            user_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            name text NOT NULL,
            nickname text
        );
        CREATE TABLE cities (
            city_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            name text NOT NULL
        );
        CREATE TABLE users_cities (
            user_id integer PRIMARY KEY REFERENCES users(user_id),
            city_id integer NOT NULL REFERENCES cities(city_id)
        );''')


@pytest.fixture
def insert_user(pool):
    async def inserter(user_id, user_name, user_nickname, city_id, city_name):
        await pool.execute(
            '''INSERT INTO users (user_id, name, nickname)
            VALUES ($1, $2, $3) ON CONFLICT (user_id) DO NOTHING''', user_id,
            user_name, user_nickname)
        await pool.execute(
            '''INSERT INTO cities (city_id, name)
            VALUES ($1, $2) ON CONFLICT (city_id) DO NOTHING''', city_id,
            city_name)
        await pool.execute(
            '''INSERT INTO users_cities (user_id, city_id)
            VALUES ($1, $2) ON CONFLICT (user_id) DO NOTHING''', user_id,
            city_id)

    return inserter


async def collect_async_iter(i):
    l = []
    async for item in i:
        l.append(item)
    return l


class TestPostgresTable:
    @pytest.fixture
    def table(self, pool):
        base_query_string = '''
            SELECT
                uc.*, u.name AS user_name, u.nickname AS user_nickname,
                c.name AS city_name
            FROM
                users u
                JOIN users_cities uc USING (user_id)
                JOIN cities c USING (city_id)'''
        query_some_string = f'{base_query_string} WHERE uc.user_id = ANY ($1)'
        return tc.PostgresTable(pool, base_query_string, query_some_string)

    async def test_all_on_empty(self, table):
        assert_that(await collect_async_iter(table.all()), empty())

    async def test_all_on_one(self, table, insert_user):
        await insert_user(1, 'u1', 'n1', 11, 'c1')
        assert_that(
            await collect_async_iter(table.all()),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_nickname='n1', city_id=11,
                    city_name='c1')))

    async def test_all_on_many(self, table, insert_user):
        await insert_user(1, 'u1', 'n1', 11, 'c1')
        await insert_user(2, 'u2', None, 11, 'c1')
        await insert_user(3, 'u3', 'n3', 12, 'c2')
        assert_that(
            await collect_async_iter(table.all()),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_nickname='n1', city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=2, user_name='u2', user_nickname=None, city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=3, user_name='u3', user_nickname='n3', city_id=12,
                    city_name='c2')))

    async def test_get_on_empty(self, table):
        assert_that(await collect_async_iter(table.get([])), empty())

    async def test_get_on_none(self, table, insert_user):
        await insert_user(1, 'u1', 'n1', 11, 'c1')
        assert_that(await collect_async_iter(table.get([])), empty())

    async def test_get_on_none_matching(self, table, insert_user):
        await insert_user(1, 'u1', 'n1', 11, 'c1')
        assert_that(await collect_async_iter(table.get([2, 3])), empty())

    async def test_get_on_one(self, table, insert_user):
        await insert_user(1, 'u1', 'n1', 11, 'c1')
        assert_that(
            await collect_async_iter(table.get([1])),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_nickname='n1', city_id=11,
                    city_name='c1')))

    async def test_get_on_many(self, table, insert_user):
        await insert_user(1, 'u1', 'n1', 11, 'c1')
        await insert_user(2, 'u2', None, 11, 'c1')
        await insert_user(3, 'u3', 'n3', 12, 'c2')
        assert_that(
            await collect_async_iter(table.get([1, 2, 3, 4])),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_nickname='n1', city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=2, user_name='u2', user_nickname=None, city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=3, user_name='u3', user_nickname='n3', city_id=12,
                    city_name='c2')))
